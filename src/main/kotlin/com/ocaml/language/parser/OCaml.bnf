{
//  parserClass="com.ocaml.language.parser.OCamlImplementationParser"
  parserClass="com.ocaml.language.parser.OCamlParser"
  parserUtilClass="com.ocaml.language.parser.OCamlParserUtils"
  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="OCaml"
  psiImplClassSuffix="Impl"
  psiPackage="com.ocaml.language.psi"
  psiImplPackage="com.ocaml.language.psi.impl"
  psiImplUtilClass="com.ocaml.language.psi.OCamlImplUtils"

  generateTokens=true
  generateTokenAccessors=false

  elementTypeHolderClass="com.ocaml.language.psi.OCamlTypes"
  elementTypeClass="com.ocaml.language.psi.api.OCamlElementType"
  tokenTypeClass="com.ocaml.language.psi.api.OCamlTokenType"

  tokens = [
          AND = "and"
          AS = "as"
          ASSERT = "assert"
          BEGIN = "begin"
          CLASS = "class"
          CONSTRAINT = "constraint"
          DO = "do"
          DONE = "done"
          DOWNTO = "downto"
          ELSE = "else"
          END = "end"
          EXCEPTION = "exception"
          EXTERNAL = "external"
          FOR = "for"
          FUN = "fun"
          FUNCTION = "function"
          FUNCTOR = "functor"
          IF = "if"
          IN = "in"
          INCLUDE = "include"
          INHERIT = "inherit"
          INITIALIZER = "initializer"
          LAZY = "lazy"
          LET = "let"
          MODULE = "module"
          MUTABLE = "mutable"
          NEW = "new"
          NONREC = "nonrec"
          OBJECT = "object"
          OF = "of"
          OPEN = "open"
          OR = "or"
          REC = "rec"
          SIG = "sig"
          STRUCT = "struct"
          THEN = "then"
          TO = "to"
          TRY = "try"
          TYPE = "type"
          VAL = "val"
          VIRTUAL = "virtual"
          WHEN = "when"
          WHILE = "while"
          WITH = "with"
          LBRACELESS = "{<"
          GREATERRBRACE = ">}"

          MOD = "mod"
          LAND = "land"
          LOR = "lor"
          LXOR = "lxor"
          LSL = "lsl"
          LSR = "lsr"
          ASR = "asr"

          TRUE = "true"
          FALSE = "false"

          METHOD = "method"
          PRIVATE = "private"
          MATCH = "match"

          UNDERSCORE = "_"

          SHORTCUT = "::"
          RIGHT_ARROW = "->"
          LEFT_ARROW = "<-"
          LARRAY = "[|"
          RARRAY = "|]"

          EQ = "="
          NOT_EQ = "!="
          COLON_EQ = ":="
          COLON_GT = ":>"
          SEMISEMI = ";;"
          L_OR = "||"
          L_AND = "&&"

          CARRET = "^"
          MINUSDOT = "-."
          PLUSEQ = "+="
          PLUS = "+"
          MINUS = "-"
          SLASH = "/"
          STAR = "*"

          COMMA = ","
          COLON = ":"
          SEMI = ";"
          SINGLE_QUOTE = "'"
          DOTDOT = ".."
          DOT = "."
          PIPE = "|"
          LPAREN = "("
          RPAREN = ")"
          LBRACE = "{"
          RBRACE = "}"
          LBRACKET = "["
          RBRACKET = "]"
          ARROBASE = "@"
          SHARP = "#"
          QUESTION_MARK = "?"
          EXCLAMATION_MARK = "!"
          DOLLAR = "$"
          BACKTICK = "`"
          TILDE = "~"
          AMPERSAND = "&"

          PERCENT = "%"

          LT = "<"
          GT = ">"

          LBRACKETGREATER = "[>"
          LBRACKETLESS = "[<"

          COMMENT = "COMMENT"
          DOC_COMMENT = "DOC_COMMENT"
    ]

  extends(".*pattern_no_exn")=pattern_no_exn
  extends(".*pattern_expression")=pattern_expression

  extends("infix_expr|non_op_expr|.*_unary_expr|expr")=expr
  extends("expr_comma_list|coloncolon_bin_expr|sign_unary_expr")=expr
  extends("simple_expr")=expr

  extends("first_class_module_expr|sharpop_expr|.*_object_expr|.*_with_local_open_expr|local_open")=simple_expr
  extends("bang_expr|list_constructor_expr|array_constructor_expr|.*_assign_expr|.*_lookup_expr")=simple_expr
  extends("record_constructor_expr|sharp_op_expr|non_op_simple_expr|simple_expr")=simple_expr
  extends("object_simple_expr")=simple_expr
}

/*
Copyright (c) 1996 Institut National de Recherche en Informatique et en Automatique.
Copyright (c) 2021 Sidharth Kuruvila
Source: https://github.com/ocaml/ocaml/blob/4.14/parsing/parser.mly
Reference: https://v2.ocaml.org/manual/lex.html

This file is used to generate the parser. It's not a copy of the original parser,
but they are similar. This parser tries to match the documentation as much as possible,
to ensure the following updates are easy -e.g., a matter of copying the documentation-,

- [BETS]: something that I removed as it was not in the documentation, but that may have been foolish
- [CHANGES]: something that is different from the documentation
- [MISSING]: something missing in the implementation that was in the documentation
*/
file ::= COMMENT
| DOC_COMMENT
| ANNOTATION // fixme: annotations are an extension and not a comment
//| unit-interface // todo: separate parser for mli
| unit-implementation

private infix_symbol_lexed ::= // PIPE is rejected, but all these are lexed alone
 DOLLAR | AMPERSAND | STAR | PLUS | MINUS | SLASH | EQ | GT | ARROBASE | CARRET
 // and all of them are lexed too (:> -> <- [< and [> are lexed but not valid)
 | NOT_EQ | COLON_EQ | L_OR | L_AND | MINUSDOT | PLUSEQ
 // These two are valid and lexed alone
 | LT | PERCENT
 // And this one is valid but dunno from which rule as it's not in CORE_OPERATOR_CHAR
 | EXCLAMATION_MARK

private prefix_symbol_lexed ::= EXCLAMATION_MARK | QUESTION_MARK | TILDE

// https://v2.ocaml.org/releases/4.14/htmlman/compunit.html#start-section
unit-implementation ::= [ module-items ]
unit-interface ::=  { specification [SEMISEMI] }*

// https://v2.ocaml.org/releases/4.14/htmlman/lex.html#sss:lex:identifiers
// [CHANGES]: using the lexer
ident ::= capitalized_ident | lowercase_ident
capitalized_ident ::= CAPITALIZED_IDENT_VALUE
lowercase_ident ::= LOWERCASE_IDENT_VALUE | UNDERSCORE // underscore alone is not lexed as lowercase
                                                       // which is *normal* but not "expected"

// https://v2.ocaml.org/releases/4.14/htmlman/lex.html#sss:integer-literals
// [CHANGES]: using the lexer
integer_literal ::= [MINUS] INTEGER_VALUE
int32_literal ::=  integer_literal "l"
int64_literal ::=  integer_literal "L"
nativeint_literal ::=  integer_literal "n"

// https://v2.ocaml.org/releases/4.14/htmlman/lex.html#sss:floating-point-literals
// [CHANGES]: using the lexer
float_literal ::= [MINUS] FLOAT_VALUE

// https://v2.ocaml.org/releases/4.14/htmlman/lex.html#sss:character-literals
// [CHANGES]: using the lexer
char_literal ::= CHAR_VALUE

// https://v2.ocaml.org/releases/4.14/htmlman/lex.html#sss:stringliterals
// [CHANGES]: using the lexer
string_literal ::= STRING_VALUE

// https://v2.ocaml.org/releases/4.14/htmlman/lex.html#sss:labelname
// [CHANGES]: label and optlab were commented out as they were not used
label_name ::= lowercase_ident
// label ::=  TILDE label_name COLON
// optlabel ::=  QUESTION_MARK label_name COLON

// https://v2.ocaml.org/releases/4.14/htmlman/lex.html#sss:lex-ops-symbols
// [CHANGES]: adding the "infix_symbol_patch"
// [CHANGES]: linenum-directive was commented out as they were not used
infix_symbol ::= INFIX_SYMBOL_VALUE | infix_symbol_lexed
prefix_symbol ::= PREFIX_SYMBOL_VALUE | prefix_symbol_lexed

//linenum-directive ::= SHARP { DIGIT }+ '"' { string-character } '"'

// https://v2.ocaml.org/releases/4.14/htmlman/names.html#sss:naming-objects
value_name ::= lowercase_ident
  | LPAREN operator_name RPAREN

operator_name ::= prefix_symbol | infix_op

infix_op ::= infix_symbol
  |  STAR | PLUS | MINUS | MINUSDOT | EQ | NOT_EQ | LT | GT | OR | L_OR | AMPERSAND | L_AND | COLON_EQ
  |  MOD | LAND | LOR | LXOR | LSL | LSR | ASR

constr_name ::= capitalized_ident

tag_name ::= capitalized_ident

typeconstr_name ::= lowercase_ident

field_name ::= lowercase_ident

module_name ::= capitalized_ident

modtype_name ::= ident

class_name ::= lowercase_ident

inst_var_name ::= lowercase_ident

method_name ::= lowercase_ident

// https://v2.ocaml.org/releases/4.14/htmlman/names.html#sss:refer-named
value_path ::= [ module_path DOT ] value_name

constr ::= [ module_path DOT ] constr_name

typeconstr ::= [ extended_module_path DOT ] typeconstr_name

field ::= [ module_path DOT ] field_name

modtype_path ::= [ extended_module_path DOT ] modtype_name

class_path ::= [ module_path DOT ] class_name

classtype_path ::= [ extended_module_path DOT ] class_name

module_path ::= module_name { DOT module_name }*

extended_module_path ::= extended_module_name { DOT extended_module_name }*

extended_module_name ::= module_name { LPAREN extended_module_path RPAREN }*

// https://v2.ocaml.org/releases/4.14/htmlman/types.html#s:typexpr
typexpr ::= typexpr_no_attr

private typexpr_no_attr ::=
    { typexpr2 { RIGHT_ARROW typexpr2 }+ | typexpr2 } // ... typexpr -> typexpr
    [AS SINGLE_QUOTE ident]                           // typexpr as ' ident

private typexpr2 ::=
    [QUESTION_MARK] label_name COLON typexpr2        // [[?]label-name:] typexpr -> typexpr
  | simple_typexpr_or_tuple

private simple_typexpr_or_tuple ::=
    simple_typexpr [ STAR simple_typexpr { STAR simple_typexpr }* ] // typexpr { * typexpr }+

private simple_typexpr ::=
    simple_typexpr2 { typeconstr } *                 // typexpr typeconstr
  | LPAREN typexpr { COMMA typexpr }* RPAREN simple_typexpr2_suffix

private simple_typexpr2_suffix ::= SHARP class_path  // ( typexpr { , typexpr } ) # class-path
| typeconstr                                         // ( typexpr { , typexpr } ) typeconstr

private simple_typexpr2 ::=
    SINGLE_QUOTE ident                               // ' ident
  | UNDERSCORE                                       // _
  | typeconstr                                       // typeconstr
  | SHARP classtype_path                             // # classtype-path
  | LPAREN typexpr RPAREN                            // ( typexpr )
  | LT [DOTDOT] GT                                   // < [..] >
  | polymorphic_variant_type                         // polymorphic-variant-type
  // Examples: type x = <a:int;> or <a:int;..> or <a:int>
  | LT method_type { COLON method_type }* [SEMI | SEMI DOTDOT] GT // < method-type { ; method-type } [; | ; ..] >

poly_typexpr ::=
    { SINGLE_QUOTE ident }+ DOT typexpr
  | typexpr

method_type ::= method_name COLON poly_typexpr

// https://v2.ocaml.org/releases/4.14/htmlman/types.html#sss:typexpr-polyvar
polymorphic_variant_type ::= LBRACKET tag_spec_first { PIPE tag_spec }* RBRACKET
  |  LBRACKETGREATER [ tag_spec ] { PIPE tag_spec }* RBRACKET
  |  LBRACKETLESS [PIPE] tag_spec_full { PIPE tag_spec_full }* [ GT { BACKTICK tag_name }+ ] RBRACKET

tag_spec_first ::= BACKTICK tag_name [ OF typexpr ]
  |  [ typexpr ] PIPE tag_spec

tag_spec ::= BACKTICK tag_name [ OF typexpr ]
  |  typexpr

tag_spec_full ::= BACKTICK tag_name [ OF [AMPERSAND] typexpr { AMPERSAND typexpr }* ]
  |  typexpr

// https://v2.ocaml.org/releases/4.14/htmlman/const.html#s:const
constant ::= integer_literal
 |  int32_literal
 |  int64_literal
 |  nativeint_literal
 |  float_literal
 |  char_literal
 |  string_literal
 |  constr
 |  FALSE
 |  TRUE
 |  LPAREN RPAREN
 |  BEGIN END
 |  LBRACKET RBRACKET
 |  LARRAY RARRAY
 |  BACKTICK tag_name

// https://v2.ocaml.org/releases/4.14/htmlman/patterns.html#s:patterns

// https://v2.ocaml.org/releases/4.14/htmlman/expr.html#s:value-expr
// [CHANGES]: added [SEMI]
private seq_expr ::= expr { SEMI expr } *  [SEMI] // expr ; expr

// [BETS]: removed coloncolon_app_rule
// [MISSING]: todo?
//  |  expr ; expr
//  |  ( expr :> typexpr )
//  |  ( expr : typexpr :> typexpr )
expr ::=
    expr_comma_list
  | minus_unary_expr | minusdot_unary_expr | prefix_unary_expr
  | non_op_expr
  | coloncolon_bin_expr
  | infix_expr

expr_comma_list ::= expr { COMMA expr } +                               // expr { , expr } +
coloncolon_bin_expr ::= expr SHORTCUT expr { rightAssociative = true }  // expr :: expr
infix_expr ::= expr infix_op expr                                       // expr infix-op expr
minus_unary_expr ::= MINUS expr                                         // - expr
minusdot_unary_expr ::= MINUSDOT expr                                   // -. expr
prefix_unary_expr ::= prefix_symbol expr                                // prefix-symbol expr

// todo: pattern_matching, labeled_simple_pattern
// [BETS]: removed "FUN LPAREN TYPE lident_list RPAREN fun_def"
// [BETS]: removed "FOR pattern_expression"
non_op_expr ::=
    LET [REC] let_binding { AND let_binding } * IN seq_expr             // let [rec] let-binding { and let-binding } in expr
  | LET MODULE module_name { LPAREN module_name COLON module_type RPAREN }* [COLON module_type] EQ module_expr IN seq_expr // let module module-name { ( module-name : module-type ) } [ : module-type ]  = module-expr in expr
  | LET EXCEPTION constr_decl IN seq_expr                               // let exception constr-decl in expr
  | FUNCTION pattern_matching                                           // function pattern-matching
  | FUN { labeled_simple_pattern } * [ COLON simple_typexpr ] RIGHT_ARROW seq_expr // fun { parameter }+ [ : typexpr ] -> expr
  | MATCH seq_expr WITH pattern_matching                                // match expr with pattern-matching
  | TRY seq_expr WITH pattern_matching                                  // try expr with pattern-matching
  | constr simple_expr                                                  // constr expr
  | BACKTICK tag_name simple_expr                                       // `tag-name expr
  | IF expr THEN expr [ELSE expr]                                       // if expr then expr [ else expr ]
  | WHILE seq_expr DO seq_expr DONE                                     // while expr do expr done
  | FOR value_name EQ seq_expr (TO | DOWNTO) seq_expr DO seq_expr DONE  // for value-name = expr ( to | downto ) expr do expr done
  | ASSERT simple_expr                                                  // assert expr
  | LAZY simple_expr                                                    // lazy expr
  | object_expr
  | simple_expr { argument } +                                         // expr { argument }+
  | simple_expr

simple_expr ::=
  local_open_group
  | non_op_simple_expr
  | record_constructor_expr
  | assign_expr
  | lookup_expr
  | array_constructor_expr
  | list_constructor_expr
  | object_simple_expr | self_copy_object_expr
  // todo: not validated
  | send_message_object_expr
  | sharpop_expr
  | first_class_module_expr

// fixme: actually, we can have "A.B expr" not just "A.b expr" (value-path)
// [BETS]: removed constr_longident
non_op_simple_expr ::= (value_path|module_path)    // value-path
  | constant                                       // constant
  | constr                                         // **** duplicate
  | BACKTICK ident                                 // **** duplicate
  | LPAREN seq_expr RPAREN                         // ( expr )
  | BEGIN [seq_expr] END                           // begin expr end
  | LPAREN seq_expr COLON typexpr RPAREN           // ( expr : typexpr )

record_constructor_expr ::=
    LBRACE record_expr RBRACE

//  { field [: typexpr] [= expr]{ ; field [: typexpr] [= expr] } [;] }
//  { expr with field [: typexpr] [= expr]{ ; field [: typexpr] [= expr] } [;] }
private record_expr ::=
    simple_expr WITH field_expr_list
  | field_expr_list

private field_expr_list ::=
    field [COLON typexpr] [EQ expr] { SEMI field [COLON typexpr] [EQ expr]}* [SEMI]

private assign_expr ::=
    field_assign_expr
  | array_assign_expr
  | string_assign_expr
  | bigarray_assign_expr

private lookup_expr ::=
    field_lookup_expr
  | array_lookup_expr
  | string_lookup_expr
  | bigarray_lookup_expr

// [CHANGES]: there is a problem about operators after "<-" that are matching the
// "... operator expr" pattern while it should include the operator in expr.
private priority_patch ::= [operator_name] expr

field_lookup_expr ::= simple_expr DOT field                                                 // expr . field
field_assign_expr ::= simple_expr DOT field LEFT_ARROW priority_patch                       // expr . field <- expr
array_lookup_expr ::= simple_expr DOT LPAREN seq_expr RPAREN                                // expr .( expr )
array_assign_expr ::= simple_expr DOT LPAREN seq_expr RPAREN LEFT_ARROW priority_patch      // expr .( expr ) <- expr
string_lookup_expr ::= simple_expr DOT LBRACKET seq_expr RBRACKET                           // expr .[ expr ]
string_assign_expr ::= simple_expr DOT LBRACKET seq_expr RBRACKET LEFT_ARROW priority_patch // expr .[ expr ] <- expr

array_constructor_expr ::= LBRACKET [expr { SEMI expr }* [SEMI]] RBRACKET // // [| expr { ; expr } [;] |]
list_constructor_expr ::= LARRAY [expr { SEMI expr }* [SEMI]] RARRAY // // [ expr { ; expr } [;] ]

// Other elements
argument ::= simple_expr
  | TILDE label_name COLON simple_expr
  | TILDE label_name
  | QUESTION_MARK label_name
  | QUESTION_MARK label_name COLON simple_expr

private local_open_group ::= local_open
 | object_copy_with_local_open_expr
 | expr_with_local_open_expr
 | list_constructor_with_local_open_expr
 | array_constructor_with_local_open_expr
 | record_constructor_with_local_open_expr

local_open ::= LET OPEN module_path IN seq_expr
expr_with_local_open_expr ::= module_path DOT LPAREN seq_expr RPAREN
list_constructor_with_local_open_expr ::= module_path DOT LBRACKET seq_expr RBRACKET
object_copy_with_local_open_expr ::= module_path DOT LBRACELESS seq_expr GREATERRBRACE
array_constructor_with_local_open_expr ::= module_path DOT LARRAY seq_expr RARRAY
record_constructor_with_local_open_expr ::= module_path DOT LBRACE seq_expr RBRACE

// [CHANGES]: was split in 4
// [CHANGES]: removed "inst_var_name" but no a good idea imo (dunno where to add it)
object_expr ::= inst_var_name LEFT_ARROW expr    // inst-var-name <- expr
| OBJECT class_body END                          // object class-body end

object_simple_expr ::= NEW class_path            // new class-path
// {< [ inst-var-name [= expr] { ; inst-var-name [= expr] } [;] ] >}
self_copy_object_expr ::= LBRACELESS [field_expr { SEMI field_expr } * [SEMI]] GREATERRBRACE
send_message_object_expr ::= simple_expr SHARP method_name // expr # method_name

private field_expr ::= inst_var_name [EQ expr]
// END

// https://v2.ocaml.org/releases/4.14/htmlman/typedecl.html#ss:typedefs
type_definition ::= TYPE [NONREC] typedef { AND typedef }*

// [BETS]: used type_params instead of optional_type_parameters
typedef ::= [type_params] typeconstr_name type_information

type_information ::= [type_equation] [type_representation] { type_constraint }*

// [BETS]: removed a bunch of stuff with private opt
type_equation ::= EQ typexpr
| private_type_equation

type_representation ::=
    EQ [PIPE] constr_decl { PIPE constr_decl } *
  | EQ record_decl
  | EQ PIPE
  | private_type_representation
  | type_extension_representation

type_params ::= type_param
  |  LPAREN type_param { COMMA type_param }* RPAREN

type_param ::= [ext_variance] SINGLE_QUOTE ident
| gadts_type_param

ext_variance ::= variance [injectivity]
  |  injectivity [variance]

variance ::= PLUS | MINUS

injectivity ::= EXCLAMATION_MARK

record_decl ::= LBRACE field_decl { SEMI field_decl }* [SEMI] RBRACE

// [BETS]: removed "| COLON constr_args RIGHT_ARROW simple_core_type"
// [BETS]: removed "| COLON simple_core_type"
constr_decl ::= gadts_constr_decl
| constr_decl_name [OF constr_args]

// true and false cannot be used as a lowercase_ident
// [BETS]: removed ()
private constr_decl_name ::= constr_name
| LBRACKET RBRACKET
| LPAREN SHORTCUT RPAREN
| TRUE | FALSE

// [MAJOR]: used simple_typeexpr
constr_args ::= simple_typexpr { STAR simple_typexpr } *
| inline_records_constr_args

field_decl ::= [MUTABLE] field_name COLON poly_type_no_attr // todo

type_constraint ::= CONSTRAINT typexpr EQ typexpr

// https://v2.ocaml.org/releases/4.14/htmlman/typedecl.html#ss:exndef
exception_definition ::= EXCEPTION constr_name EQ constr
| exception_specification

exception_specification ::= EXCEPTION constr_decl

// https://v2.ocaml.org/releases/4.14/htmlman/classes.html#ss:classes:class-types
// [CHANGES]: using simple_core_type_or_tuple
// [BETS]: using RAW opt label
// [OPT]: go back to two lines?
class_type ::=
    QUESTION_MARK lowercase_ident COLON simple_typexpr_or_tuple RIGHT_ARROW class_type
  | lowercase_ident COLON simple_typexpr_or_tuple RIGHT_ARROW class_type
  | simple_typexpr_or_tuple RIGHT_ARROW class_type
  | class_body_type

class_body_type ::=
      OBJECT [LPAREN typexpr RPAREN] { class_field_spec } * END
    | LBRACKET typexpr { COMMA typexpr } * RBRACKET classtype_path
    | LET OPEN module_path IN class_body_type

class_field_spec ::=
    INHERIT class_body_type
  | VAL [MUTABLE] [VIRTUAL] inst_var_name COLON typexpr
  | VAL VIRTUAL MUTABLE inst_var_name COLON typexpr
  | METHOD [PRIVATE] [VIRTUAL] method_name COLON poly_typexpr
  | METHOD VIRTUAL PRIVATE method_name COLON poly_typexpr
  | CONSTRAINT typexpr EQ typexpr

// https://v2.ocaml.org/releases/4.14/htmlman/classes.html#ss:class-expr
// todo
class_expr ::=
    class_simple_expr { simple_expr | label_expr } *
  | class_simple_expr
  | FUN class_fun_def
  | let_bindings IN class_expr

private class_simple_expr ::=
    LBRACKET typexpr { COMMA typexpr } * RBRACKET class_longident
  | class_longident
  | OBJECT class_body ? END
  | LPAREN class_expr COLON class_type RPAREN
  | LPAREN class_expr RPAREN

class_field ::=
    INHERIT class_expr [AS lowercase_ident]
  | INHERIT [EXCLAMATION_MARK] class_expr [AS lowercase_ident]
  | VAL [MUTABLE] inst_var_name [COLON typexpr] EQ seq_expr
  | VAL [EXCLAMATION_MARK] [MUTABLE] inst_var_name [COLON typexpr] EQ seq_expr
  | VAL [MUTABLE] VIRTUAL inst_var_name COLON typexpr
  | VAL VIRTUAL MUTABLE inst_var_name COLON typexpr
  | METHOD [PRIVATE] method_name class_field_strict_binding
  | METHOD EXCLAMATION_MARK [PRIVATE] method_name class_field_strict_binding
  | METHOD [PRIVATE] method_name COLON poly_typexpr EQ seq_expr
  | METHOD EXCLAMATION_MARK [PRIVATE] method_name COLON poly_typexpr EQ seq_expr
  | METHOD [PRIVATE] VIRTUAL method_name COLON poly_typexpr
  | METHOD VIRTUAL PRIVATE method_name COLON poly_typexpr
  | CONSTRAINT typexpr EQ typexpr
  | INITIALIZER seq_expr

// [BETS]: unsure if this pattern is the correct one
private class_field_strict_binding ::=
    { labeled_simple_pattern } * [COLON typexpr] EQ seq_expr

// https://v2.ocaml.org/releases/4.14/htmlman/classes.html#sss:class-body

// https://v2.ocaml.org/releases/4.14/htmlman/classes.html#ss:class-def
class_definition ::= CLASS class_binding { AND class_binding } *

class_binding ::=
    [VIRTUAL] [class_type_parameters] class_name { labeled_simple_pattern }* // todo
    [COLON class_type] EQ class_expr

private class_type_parameters ::= LBRACKET type_parameters RBRACKET
type_parameters ::= SINGLE_QUOTE ident { COMMA SINGLE_QUOTE ident }*

// https://v2.ocaml.org/releases/4.14/htmlman/classes.html#ss:class-spec
class_specification ::= CLASS class_spec { AND class_spec } *
class_spec ::= [VIRTUAL] [class_type_parameters] class_name COLON class_type

// https://v2.ocaml.org/releases/4.14/htmlman/classes.html#ss:classtype
classtype_definition ::= CLASS TYPE classtype_def { AND classtype_def } *
classtype_def ::= [VIRTUAL] [class_type_parameters] class_name EQ class_body_type

// https://v2.ocaml.org/releases/4.14/htmlman/modtypes.html#s:modtypes
private base_module_type ::= modtype_path
  | SIG [SEMISEMI] { specification [SEMISEMI] }* END // added [SEMISEMI]
  | FUNCTOR LPAREN module_name COLON module_type RPAREN RIGHT_ARROW module_type
  | LPAREN module_type RPAREN
  | module_type_typeof

private module_type_suffix ::=
    RIGHT_ARROW module_type
    | WITH mod_constraint { AND mod_constraint }*

module_type ::= base_module_type [module_type_suffix]

// [BETS]: replaced previous names/paths with others
mod_constraint ::=
    TYPE [type_params] typeconstr type_equation { type_constraint }*
  | MODULE module_path EQ extended_module_path
  | signature_substitution_mod_constraint

// [BETS]: removed module_alias ::= MODULE (capitalized_ident|UNDERSCORE) EQ mod_longident
specification ::=
    value_description
  | internal_type_specification
  | exception_specification
  | class_specification
  | classtype_definition
  | module_declaration
  | module_type_declaration
  | open_statement
  | sig_include_statement
  | recursive_module_extension_spec
  | module_alias_spec
  | signature_substitution_spec
  | primitive_declaration

private value_description ::= VAL value_name COLON typexpr

private module_declaration ::=
    MODULE module_name COLON module_type
  | MODULE module_name LPAREN module_name COLON module_type RPAREN COLON module_type

private module_type_declaration ::=
    MODULE TYPE modtype_name EQ module_type
  | MODULE TYPE modtype_name

private open_statement ::= OPEN module_path

private sig_include_statement ::= INCLUDE module_type

private internal_type_specification ::= type_extension_specification // priority
| type_definition

// https://v2.ocaml.org/releases/4.14/htmlman/modules.html#s:module-expr
module-items ::= // todo: seq_expr and fixme: definition|specification
{ SEMISEMI }* (definition|specification|seq_expr)? { { SEMISEMI }* ( definition | specification | SEMISEMI seq_expr) }* { SEMISEMI }*

// todo
definition ::=
    let_bindings
  | internal_type_definition
  | exception_definition
  | module_binding
  | module_type_declaration
  | open_statement
  | class_definition
  | classtype_definition
  | str_include_statement
  | recursive_module_extension_def
  | primitive_declaration

private internal_type_definition ::= type_extension_definition // first
| type_definition

// https://v2.ocaml.org/releases/4.14/htmlman/intfc.html#s:c-overview
primitive_declaration ::=
    EXTERNAL value_name COLON typexpr EQ external_declaration

external_declaration ::= STRING_VALUE [ STRING_VALUE [ STRING_VALUE ] ]

// https://v2.ocaml.org/releases/4.14/htmlman/recursivemodules.html#s:recursive-modules
// [BETS]: discard rec_module_bindings ; rec_module_binding ; and_module_binding
private recursive_module_extension_def ::=
    MODULE REC module_name COLON module_type EQ module_expr
    { AND module_name COLON module_type EQ module_expr } *

private recursive_module_extension_spec ::=
    MODULE REC module_name COLON module_type { AND module_name COLON module_type } *

// https://v2.ocaml.org/releases/4.14/htmlman/generalizedopens.html#s:generalized-open

// https://v2.ocaml.org/releases/4.14/htmlman/extensiblevariants.html
private type_extension_representation ::= EQ DOTDOT
| PRIVATE EQ DOTDOT

// [BETS]: removed [NONREC]
// [BETS]: removed optional_type_parameters
// [BETS]: removed type_longident and used typeconstr
private type_extension_specification ::= TYPE [type_params] typeconstr type_extension_spec
private type_extension_definition ::= TYPE [type_params] typeconstr type_extension_def

type_extension_spec ::= PLUSEQ [PRIVATE] [PIPE] constr_decl { PIPE constr_decl } *
type_extension_def ::= PLUSEQ [PRIVATE] [PIPE] constr_def { PIPE constr_def } *

// [BETS]: used 'constr_name' instead of '... | () | [] | true | false'
// [BETS]: used 'constr' instead of '... | () | [] | true | false'
constr_def ::= constr_decl | constr_name EQ constr

// https://v2.ocaml.org/releases/4.14/htmlman/moduletypeof.html#s:module-type-of
private module_type_typeof ::= MODULE TYPE OF module_expr

// (3/3) https://v2.ocaml.org/releases/4.14/htmlman/privatetypes.html#s:private-types
private private_type_equation ::= EQ PRIVATE typexpr

private private_type_representation ::=
    EQ PRIVATE [PIPE] constr_decl { PIPE constr_decl } *
  | EQ PRIVATE record_decl
  | EQ PRIVATE PIPE

// (1/1) https://v2.ocaml.org/releases/4.14/htmlman/modulealias.html#s:module-alias
private module_alias_spec ::= MODULE module_name EQ module_path

// (1/1) https://v2.ocaml.org/releases/4.14/htmlman/signaturesubstitution.html#s:signature-substitution
private signature_substitution_mod_constraint ::=
    TYPE [type_params] typeconstr_name COLON_EQ typexpr
    | MODULE module_path COLON_EQ extended_module_path
    | MODULE TYPE modtype_path EQ module_type
    | MODULE TYPE modtype_path COLON_EQ module_type

private signature_substitution_spec ::=
    TYPE type_subst { AND type_subst }*
    | MODULE module_name COLON_EQ extended_module_path
    | MODULE TYPE module_name COLON_EQ module_type

type_subst ::= [type_params] typeconstr_name COLON_EQ typexpr { type_constraint }*

// (1/1) https://v2.ocaml.org/releases/4.14/htmlman/inlinerecords.html#s:inline-records
private inline_records_constr_args ::= record_decl

// (2/4) https://v2.ocaml.org/releases/4.14/htmlman/gadts.html#s:gadts
// todo: missing two
private gadts_constr_decl ::= constr_name COLON [constr_args RIGHT_ARROW] typexpr
private gadts_type_param ::= [variance] UNDERSCORE

// (1/1) https://v2.ocaml.org/releases/4.14/htmlman/bigarray.html#s:bigarray-access
bigarray_lookup_expr ::= simple_expr DOT LBRACE expr_comma_list RBRACE // expr .{ expr {, expr} }
bigarray_assign_expr ::= simple_expr DOT LBRACE expr_comma_list RBRACE LEFT_ARROW expr // expr .{ expr {, expr} } <- expr







// [CHANGE]: added all 4 below
BOOL_VALUE ::= TRUE | FALSE

functor_arg ::=
    LPAREN RPAREN
  | LPAREN functor_arg_name COLON module_type RPAREN

functor_arg_name ::=
    capitalized_ident
  | UNDERSCORE

functor_args ::=
    functor_arg +

module_expr_sufix ::=
    (LPAREN module_expr RPAREN | LPAREN RPAREN | module_expr attribute) +

module_expr ::=
    mod_longident module_expr_sufix?
  | STRUCT module-items END module_expr_sufix?
  | FUNCTOR functor_args RIGHT_ARROW module_expr module_expr_sufix?
  | LPAREN module_expr COLON module_type RPAREN
  | LPAREN module_expr RPAREN
  | LPAREN VAL expr RPAREN
  | LPAREN VAL expr COLON package_type RPAREN
  | LPAREN VAL expr COLON package_type COLON_GT package_type
    RPAREN
  | LPAREN VAL expr COLON_GT package_type RPAREN
  | extension

str_include_statement ::=
    INCLUDE module_expr

// [CHANGES]: using (EQ module_expr)?
module_binding_body ::=
    EQ module_expr
  | COLON module_type (EQ module_expr)?
  | functor_arg module_binding_body

module_binding ::=
    MODULE (capitalized_ident|UNDERSCORE) module_binding_body
///* Class expressions */

class_fun_def ::=
    labeled_simple_pattern + RIGHT_ARROW class_expr

//
class_body ::=
   class_self_pattern ? class_fields ?
//
//
class_self_pattern ::=
    LPAREN pattern_expression RPAREN
  | LPAREN pattern_expression COLON core_type RPAREN


class_fields ::=
    class_field +

///* Core expressions */
labeled_simple_pattern ::=
    QUESTION_MARK LPAREN label_let_pattern opt_default ? RPAREN
  | QUESTION_MARK label_var
  | OPTLABEL LPAREN let_pattern opt_default ? RPAREN
  | OPTLABEL pattern_var
  | TILDE LPAREN label_let_pattern RPAREN
  | TILDE label_var
  | LABEL_OP simple_pattern
  | simple_pattern

pattern_var ::=
    lowercase_ident
  | UNDERSCORE

opt_default ::=
    EQ seq_expr

label_let_pattern ::=
    label_var (COLON core_type)?

label_var ::=
    lowercase_ident

let_pattern ::=
    pattern_expression (COLON core_type) ?

first_class_module_expr ::=
    LPAREN MODULE module_expr (COLON package_type) ? RPAREN

sharpop_expr ::= simple_expr SHARPOP simple_expr

label_expr ::=
    LABEL_OP simple_expr //%prec below_SHARP
  | TILDE label_ident
  | QUESTION_MARK label_ident
  | OPTLABEL simple_expr //%prec below_SHARP

label_ident ::=
    lowercase_ident

lident_list ::=
    lowercase_ident +

val_decl ::= value_name

// [CHANGES]: added let_binding_expr
let_binding_body_expr ::= seq_expr

private internal_let_binding_body ::=
    val_decl fun_binding
  | value_name COLON typevar_list DOT core_type EQ let_binding_body_expr
  | value_name COLON TYPE lident_list DOT core_type EQ let_binding_body_expr
  | pattern_no_exn EQ let_binding_body_expr
  | simple_pattern_not_ident COLON core_type EQ let_binding_body_expr

let_binding ::= internal_let_binding_body

let_bindings ::= LET [REC] let_binding { AND let_binding } *


//
private fun_binding ::=
    strict_binding
  | type_constraint_stro EQ let_binding_body_expr

private strict_binding ::=
    EQ let_binding_body_expr
  | labeled_simple_pattern fun_binding
  | LPAREN TYPE lident_list RPAREN fun_binding

pattern_matching ::=
    [PIPE] match_case (PIPE match_case) *

match_case ::=
    pattern_expression RIGHT_ARROW seq_expr
  | pattern_expression WHEN seq_expr RIGHT_ARROW seq_expr
  | pattern_expression RIGHT_ARROW DOT

//
type_constraint_stro ::=
    COLON core_type
  | COLON core_type COLON_GT core_type
  | COLON_GT core_type
//
//opt_type_constraint ::=
//    type_constraint
//  | /* empty */
//
//
///* Patterns */
//
pattern_expression ::=
    val_ident_pattern_expression
  | comma_list_pattern_expression  //%prec below_COMMA
  | coloncolon_separated_pattern_expression
  | bar_pattern_expression
  | exception_pattern_expression
  | attribute_pattern_expression
  | pattern_gen_pattern_expression

val_ident_pattern_expression ::=
    pattern_expression AS value_name

coloncolon_separated_pattern_expression ::=
    pattern_expression SHORTCUT pattern_expression

bar_pattern_expression ::=
    pattern_expression PIPE pattern_expression

pattern_gen_pattern_expression ::=
    pattern_gen

attribute_pattern_expression ::=
    pattern_expression attribute

exception_pattern_expression ::= EXCEPTION pattern_expression //%prec prec_constr_appl

comma_list_pattern_expression ::=
    pattern_expression (COMMA pattern_expression) +


pattern_no_exn ::=
    val_ident_pattern_no_exn
  | comma_list_pattern_no_exn  //%prec below_COMMA
  | coloncolon_separated_pattern_no_exn
  | bar_pattern_no_exn
  | attribute_pattern_no_exn
  | pattern_gen_pattern_no_exn

val_ident_pattern_no_exn ::=
    pattern_no_exn AS value_name

coloncolon_separated_pattern_no_exn ::=
    pattern_no_exn SHORTCUT pattern_no_exn

bar_pattern_no_exn ::=
    pattern_no_exn PIPE pattern_no_exn

pattern_gen_pattern_no_exn ::=
    pattern_gen

attribute_pattern_no_exn ::=
    pattern_no_exn attribute

comma_list_pattern_no_exn ::=
    pattern_no_exn (COMMA pattern_expression) +

pattern_gen ::=
    constr_longident pattern_expression //%prec prec_constr_appl
  | name_tag pattern_expression //%prec prec_constr_appl
  | simple_pattern
  | LPAREN SHORTCUT RPAREN LPAREN pattern_expression COMMA pattern_expression RPAREN
  | LAZY simple_pattern

simple_pattern ::=
    val_decl //%prec below_EQUAL
  | simple_pattern_not_ident

simple_pattern_not_ident ::=
  UNDERSCORE
  | signed_constant DOTDOT signed_constant
  | signed_constant
  | constr_longident
  | name_tag
  | SHARP type_longident
  | LBRACE lbl_pattern_list RBRACE
  | LBRACKET pattern_semi_list SEMI ? RBRACKET
  | LARRAY pattern_semi_list SEMI ? RARRAY
  | LARRAY RARRAY
  | LPAREN pattern_expression RPAREN
  | LPAREN pattern_expression COLON core_type RPAREN
  | LPAREN MODULE capitalized_ident RPAREN
  | LPAREN MODULE capitalized_ident COLON package_type RPAREN
  | extension

pattern_semi_list ::=
    pattern_expression (SEMI pattern_expression) *

lbl_pattern_list ::=
    lbl_pattern (SEMI lbl_pattern) * (SEMI UNDERSCORE)? SEMI?

lbl_pattern ::=
    label_longident opt_pattern_type_constraint ? EQ pattern_expression
  | label_longident opt_pattern_type_constraint ?


opt_pattern_type_constraint ::=
    COLON core_type

///* Polymorphic types */

typevar_list ::=
    (SINGLE_QUOTE ident) +

poly_type_no_attr ::=
        core_type_no_attr
      | typevar_list DOT core_type_no_attr


///* Core types */
//
core_type ::=
    // [CHANGE] Add support for COLON_GT
    core_type_no_attr (attribute|COLON_GT core_type_no_attr)?

core_type_no_attr ::=
    (minusgreater_coretype2| core_type2) (AS SINGLE_QUOTE ident)?

minusgreater_coretype2 ::=
    core_type2 (RIGHT_ARROW core_type2)+

core_type2 ::=
    QUESTION_MARK lowercase_ident COLON core_type2
  | OPTLABEL core_type2
  | lowercase_ident COLON core_type2
  | simple_core_type_or_tuple

simple_core_type ::=
    simple_core_type2 sumple_core_type2_suffix * ////%prec below_SHARP
  | LPAREN core_type_comma_list RPAREN ////%prec below_SHARP

sumple_core_type2_suffix ::=
    SHARP class_longident
    | type_longident

simple_core_type2 ::=
    SINGLE_QUOTE ident (DOT SINGLE_QUOTE ident)?
  | UNDERSCORE
  | type_longident
  | LPAREN core_type_comma_list RPAREN type_longident
  // [CHANGES]: uncommented all
  | LT meth_list GT
  | LT GT
  | SHARP class_longident
  | LPAREN core_type_comma_list RPAREN SHARP class_longident
  | LBRACKET tag_field RBRACKET
/* PR#3835: this is not LR(1), would need lookahead=2
  | LBRACKET simple_core_type RBRACKET
*/
  | LBRACKET PIPE? row_field_list RBRACKET
  | LBRACKETGREATER row_field_list RBRACKET
  | LBRACKETLESS row_field_list RBRACKET
//  | LBRACKETGREATER PIPE ? row_field_list RBRACKET
  | LBRACKETGREATER RBRACKET
//  | LBRACKETLESS PIPE ? row_field_list RBRACKET
//  | LBRACKETLESS PIPE ? row_field_list GT name_tag_list RBRACKET
  | LPAREN MODULE package_type RPAREN
  | extension

package_type ::=
    module_type

row_field_list ::=
    row_field (PIPE row_field)*

row_field ::=
    tag_field
  | simple_core_type

tag_field ::=
    name_tag OF AMPERSAND ? amper_type_list
  | name_tag

amper_type_list ::=
    core_type_no_attr (AMPERSAND core_type_no_attr) *
//
//name_tag_list ::=
//    name_tag
//  | name_tag_list name_tag
//
simple_core_type_or_tuple ::=
    simple_core_type (STAR core_type_list) ?

core_type_comma_list ::=
    core_type (COMMA core_type) *

core_type_list ::=
    simple_core_type (STAR simple_core_type) *

meth_list ::=
    field_semi meth_list
  | field_semi
  | field_stro
  | DOTDOT

field_stro ::=
  label COLON poly_type_no_attr

field_semi ::=
  label COLON poly_type_no_attr SEMI

label ::=
    lowercase_ident

///* Constants */
//
constant_stro ::=
    INTEGER_VALUE
  | CHAR_VALUE
  | STRING_VALUE
  | FLOAT_VALUE

signed_constant ::=
    constant_stro
  | MINUS INTEGER_VALUE
  | MINUS FLOAT_VALUE
  | PLUS INTEGER_VALUE
  | PLUS FLOAT_VALUE

constr_longident ::=
    mod_longident       ////%prec below_DOT
  | LBRACKET RBRACKET
  | LPAREN RPAREN
  // [CHANGE]: add BOOL_VALUE and remove both
  | BOOL_VALUE

label_longident ::=
    lowercase_ident
  | mod_longident DOT lowercase_ident

type_longident ::=
    lowercase_ident
    // [CHANGE]: stop using mod_ext as we can have A.B(C).t
//  | mod_ext_longident DOT lowercase_ident
    | capitalized_ident (LPAREN capitalized_ident (DOT capitalized_ident)* RPAREN)? DOT type_longident

mod_longident ::=
    capitalized_ident (DOT capitalized_ident)*

class_longident ::=
    lowercase_ident
  | { capitalized_ident (DOT capitalized_ident)* } DOT lowercase_ident

/* Miscellaneous */

name_tag ::=
    BACKTICK ident