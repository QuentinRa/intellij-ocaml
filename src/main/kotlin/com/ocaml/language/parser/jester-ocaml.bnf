{
  tokens = [
        AND = "and"
        AS = "as"
        ASSERT = "assert"
        BEGIN = "begin"
        CLASS = "class"
        CONSTRAINT = "constraint"
        DO = "do"
        DONE = "done"
        DOWNTO = "downto"
        ELSE = "else"
        END = "end"
        EXCEPTION = "exception"
        EXTERNAL = "external"
        FOR = "for"
        FUN = "fun"
        FUNCTION = "function"
        FUNCTOR = "functor"
        IF = "if"
        IN = "in"
        INCLUDE = "include"
        INHERIT = "inherit"
        INITIALIZER = "initializer"
        LAZY = "lazy"
        LET = "let"
        MODULE = "module"
        MUTABLE = "mutable"
        NEW = "new"
        NONREC = "nonrec"
        OBJECT = "object"
        OF = "of"
        OPEN = "open"
        OR = "or"
        REC = "rec"
        SIG = "sig"
        STRUCT = "struct"
        THEN = "then"
        TO = "to"
        TRY = "try"
        TYPE = "type"
        VAL = "val"
        VIRTUAL = "virtual"
        WHEN = "when"
        WHILE = "while"
        WITH = "with"
        LBRACELESS = "{<"
        GREATERRBRACE = ">}"

        MOD = "mod"
        LAND = "land"
        LOR = "lor"
        LXOR = "lxor"
        LSL = "lsl"
        LSR = "lsr"
        ASR = "asr"

        TRUE = "true"
        FALSE = "false"

        METHOD = "method"
        PRIVATE = "private"
        MATCH = "match"

        UNDERSCORE = "_"

        SHORTCUT = "::"
        RIGHT_ARROW = "->"
        LEFT_ARROW = "<-"
        LARRAY = "[|"
        RARRAY = "|]"

        EQ = "="
        NOT_EQ = "!="
        COLON_EQ = ":="
        COLON_GT = ":>"
        SEMISEMI = ";;"
        L_OR = "||"
        L_AND = "&&"

        CARRET = "^"
        MINUSDOT = "-."
        PLUS = "+"
        MINUS = "-"
        SLASH = "/"
        STAR = "*"

        COMMA = ","
        COLON = ":"
        SEMI = ";"
        SINGLE_QUOTE = "'"
        DOTDOT = ".."
        DOT = "."
        PIPE = "|"
        LPAREN = "("
        RPAREN = ")"
        LBRACE = "{"
        RBRACE = "}"
        LBRACKET = "["
        RBRACKET = "]"
        ARROBASE = "@"
        SHARP = "#"
        QUESTION_MARK = "?"
        EXCLAMATION_MARK = "!"
        DOLLAR = "$"
        BACKTICK = "`"
        TILDE = "~"
        AMPERSAND = "&"

        PERCENT = "%"

        LT = "<"
        GT = ">"

        LBRACKETGREATER = "[>"
        LBRACKETLESS = "[<"

        LCHAR = "regexp:[a-z]"
        UCHAR = "regexp:[A-Z]"
        DIGIT = "regexp:[0-9]"
  ]
}

// I want to remove these, it's stupid
private regular-string-char ::= regular-char
private regular-char ::= LCHAR | UCHAR | DIGIT
private any-char ::= regular-char

// https://v2.ocaml.org/releases/4.14/htmlman/toplevel.html
private statement ::=
  { definition }+ [SEMISEMI]
  | expr [SEMISEMI]
  // | directive // todo
  | SEMISEMI
  | COMMENT | DOC_COMMENT | ANNOTATION // fixme: ++ parser definition
  // fixme: different parser for a .mli
  | { specification }+ [SEMISEMI]

directive ::= SHARP IDENT [ directive-argument ] [SEMISEMI]

directive-argument ::= string-literal
  |  integer-literal
  |  value-path
  |  TRUE | FALSE

// https://v2.ocaml.org/releases/4.14/htmlman/lex.html#sss:lex:identifiers
//IDENT ::=  (letter | UNDERSCORE) { letter | DIGIT | UNDERSCORE | SINGLE_QUOTE }*
//CAPITALIZED_IDENT ::=  (UCHAR) { letter | DIGIT | UNDERSCORE | SINGLE_QUOTE }*
//LOWERCASE_IDENT ::= (LCHAR | UNDERSCORE) { letter | DIGIT | UNDERSCORE | SINGLE_QUOTE }*
//letter ::=  UCHAR | LCHAR

// https://v2.ocaml.org/releases/4.14/htmlman/lex.html#sss:integer-literals
// fixme: ranges are incorrect
integer-literal ::= [MINUS] (DIGIT) { DIGIT | UNDERSCORE }*
  |  [MINUS] ("0x" | "0X") (DIGIT | UCHAR | LCHAR) { DIGIT | UCHAR | LCHAR | UNDERSCORE }*
  |  [MINUS] ("0o" | "0O") (DIGIT) { DIGIT | UNDERSCORE }*
  |  [MINUS] ("0b" | "0B") (DIGIT) { DIGIT | UNDERSCORE }*

int32-literal ::=  integer-literal "l"

int64-literal ::=  integer-literal "L"

nativeint-literal ::=  integer-literal "n"

// https://v2.ocaml.org/releases/4.14/htmlman/lex.html#sss:floating-point-literals
// fixme: ranges are incorrect
// Add to change the expression as the parser would parse an "int" as a "float" otherwise
// (it doesn't follow the rule of the longest)
float-literal ::=
  [MINUS] (DIGIT) { DIGIT | UNDERSCORE }* DOT { DIGIT | UNDERSCORE }*
  | [MINUS] (DIGIT) { DIGIT | UNDERSCORE }* DOT { DIGIT | UNDERSCORE }* ("e" | "E") [PLUS | MINUS] (DIGIT) { DIGIT | UNDERSCORE }*
  | [MINUS] ("0x" | "0X") (DIGIT | UCHAR | LCHAR) { DIGIT | UCHAR | LCHAR | UNDERSCORE }*  [DOT { DIGIT | UCHAR | LCHAR | UNDERSCORE }*] [("p" | "P") [PLUS | MINUS] (DIGIT) { DIGIT | UNDERSCORE }*]

// https://v2.ocaml.org/releases/4.14/htmlman/lex.html#sss:character-literals
// fixme: ranges are incorrect
char-literal ::= CHAR_VALUE
  |  SINGLE_QUOTE escape-sequence SINGLE_QUOTE

private escape-sequence ::= "\\" ("\\" | '"' | SINGLE_QUOTE | "n" | "t" | "b" | "r" | "space")
  |  "\\" (DIGIT) (DIGIT) (DIGIT)
  |  "\\x" (DIGIT | UCHAR | LCHAR) (DIGIT | UCHAR | LCHAR)
  |  "\\o" (DIGIT) (DIGIT) (DIGIT)

// https://v2.ocaml.org/releases/4.14/htmlman/lex.html#sss:stringliterals
// Strings are handled in the lexer (to avoid keywords parsed in strings etc.)
string-literal ::= STRING_VALUE
  |  LBRACE quoted-string-id PIPE { any-char } PIPE quoted-string-id RBRACE

private quoted-string-id ::= { LCHAR | UNDERSCORE }

private string-character ::= regular-string-char
  |  escape-sequence
  |  "\\u" { { DIGIT | UCHAR | LCHAR }+ }
  |  "\\newline" { "space" | "tab" }