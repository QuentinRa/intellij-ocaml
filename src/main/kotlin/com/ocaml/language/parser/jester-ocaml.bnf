{
  tokens = [
        AND = "and"
        AS = "as"
        ASSERT = "assert"
        BEGIN = "begin"
        CLASS = "class"
        CONSTRAINT = "constraint"
        DO = "do"
        DONE = "done"
        DOWNTO = "downto"
        ELSE = "else"
        END = "end"
        EXCEPTION = "exception"
        EXTERNAL = "external"
        FOR = "for"
        FUN = "fun"
        FUNCTION = "function"
        FUNCTOR = "functor"
        IF = "if"
        IN = "in"
        INCLUDE = "include"
        INHERIT = "inherit"
        INITIALIZER = "initializer"
        LAZY = "lazy"
        LET = "let"
        MODULE = "module"
        MUTABLE = "mutable"
        NEW = "new"
        NONREC = "nonrec"
        OBJECT = "object"
        OF = "of"
        OPEN = "open"
        OR = "or"
        REC = "rec"
        SIG = "sig"
        STRUCT = "struct"
        THEN = "then"
        TO = "to"
        TRY = "try"
        TYPE = "type"
        VAL = "val"
        VIRTUAL = "virtual"
        WHEN = "when"
        WHILE = "while"
        WITH = "with"
        LBRACELESS = "{<"
        GREATERRBRACE = ">}"

        MOD = "mod"
        LAND = "land"
        LOR = "lor"
        LXOR = "lxor"
        LSL = "lsl"
        LSR = "lsr"
        ASR = "asr"

        TRUE = "true"
        FALSE = "false"

        METHOD = "method"
        PRIVATE = "private"
        MATCH = "match"

        UNDERSCORE = "_"

        SHORTCUT = "::"
        RIGHT_ARROW = "->"
        LEFT_ARROW = "<-"
        LARRAY = "[|"
        RARRAY = "|]"

        EQ = "="
        NOT_EQ = "!="
        COLON_EQ = ":="
        COLON_GT = ":>"
        SEMISEMI = ";;"
        L_OR = "||"
        L_AND = "&&"

        CARRET = "^"
        MINUSDOT = "-."
        PLUS = "+"
        MINUS = "-"
        SLASH = "/"
        STAR = "*"

        COMMA = ","
        COLON = ":"
        SEMI = ";"
        SINGLE_QUOTE = "'"
        DOTDOT = ".."
        DOT = "."
        PIPE = "|"
        LPAREN = "("
        RPAREN = ")"
        LBRACE = "{"
        RBRACE = "}"
        LBRACKET = "["
        RBRACKET = "]"
        ARROBASE = "@"
        SHARP = "#"
        QUESTION_MARK = "?"
        EXCLAMATION_MARK = "!"
        DOLLAR = "$"
        BACKTICK = "`"
        TILDE = "~"
        AMPERSAND = "&"

        PERCENT = "%"

        LT = "<"
        GT = ">"

        LBRACKETGREATER = "[>"
        LBRACKETLESS = "[<"

        LCHAR = "regexp:[a-z]"
        UCHAR = "regexp:[A-Z]"
        DIGIT = "regexp:[0-9]"
  ]
}

// I want to remove these, it's stupid
private regular-string-char ::= regular-char
private regular-char ::= LCHAR | UCHAR | DIGIT
private any-char ::= regular-char

// https://v2.ocaml.org/releases/4.14/htmlman/toplevel.html
private statement ::=
  { definition }+ [SEMISEMI]
  | expr [SEMISEMI]
  // | directive // todo
  | SEMISEMI
  | COMMENT | DOC_COMMENT | ANNOTATION // fixme: ++ parser definition
  // fixme: different parser for a .mli
  | { specification }+ [SEMISEMI]

directive ::= SHARP IDENT [ directive-argument ] [SEMISEMI]

directive-argument ::= string-literal
  |  integer-literal
  |  value-path
  |  TRUE | FALSE

// https://v2.ocaml.org/releases/4.14/htmlman/lex.html#sss:lex:identifiers
//IDENT ::=  (letter | UNDERSCORE) { letter | DIGIT | UNDERSCORE | SINGLE_QUOTE }*
//CAPITALIZED_IDENT ::=  (UCHAR) { letter | DIGIT | UNDERSCORE | SINGLE_QUOTE }*
//LOWERCASE_IDENT ::= (LCHAR | UNDERSCORE) { letter | DIGIT | UNDERSCORE | SINGLE_QUOTE }*
//letter ::=  UCHAR | LCHAR

// https://v2.ocaml.org/releases/4.14/htmlman/lex.html#sss:integer-literals
// fixme: ranges are incorrect
integer-literal ::= [MINUS] (DIGIT) { DIGIT | UNDERSCORE }*
  |  [MINUS] ("0x" | "0X") (DIGIT | UCHAR | LCHAR) { DIGIT | UCHAR | LCHAR | UNDERSCORE }*
  |  [MINUS] ("0o" | "0O") (DIGIT) { DIGIT | UNDERSCORE }*
  |  [MINUS] ("0b" | "0B") (DIGIT) { DIGIT | UNDERSCORE }*

int32-literal ::=  integer-literal "l"

int64-literal ::=  integer-literal "L"

nativeint-literal ::=  integer-literal "n"

// https://v2.ocaml.org/releases/4.14/htmlman/lex.html#sss:floating-point-literals
// fixme: ranges are incorrect
// Add to change the expression as the parser would parse an "int" as a "float" otherwise
// (it doesn't follow the rule of the longest)
float-literal ::=
  [MINUS] (DIGIT) { DIGIT | UNDERSCORE }* DOT { DIGIT | UNDERSCORE }*
  | [MINUS] (DIGIT) { DIGIT | UNDERSCORE }* DOT { DIGIT | UNDERSCORE }* ("e" | "E") [PLUS | MINUS] (DIGIT) { DIGIT | UNDERSCORE }*
  | [MINUS] ("0x" | "0X") (DIGIT | UCHAR | LCHAR) { DIGIT | UCHAR | LCHAR | UNDERSCORE }*  [DOT { DIGIT | UCHAR | LCHAR | UNDERSCORE }*] [("p" | "P") [PLUS | MINUS] (DIGIT) { DIGIT | UNDERSCORE }*]

// https://v2.ocaml.org/releases/4.14/htmlman/lex.html#sss:character-literals
// fixme: ranges are incorrect
char-literal ::= CHAR_VALUE
  |  SINGLE_QUOTE escape-sequence SINGLE_QUOTE

private escape-sequence ::= "\\" ("\\" | '"' | SINGLE_QUOTE | "n" | "t" | "b" | "r" | "space")
  |  "\\" (DIGIT) (DIGIT) (DIGIT)
  |  "\\x" (DIGIT | UCHAR | LCHAR) (DIGIT | UCHAR | LCHAR)
  |  "\\o" (DIGIT) (DIGIT) (DIGIT)

// https://v2.ocaml.org/releases/4.14/htmlman/lex.html#sss:stringliterals
// Strings are handled in the lexer (to avoid keywords parsed in strings etc.)
string-literal ::= STRING_VALUE
  |  LBRACE quoted-string-id PIPE { any-char } PIPE quoted-string-id RBRACE

private quoted-string-id ::= { LCHAR | UNDERSCORE }

private string-character ::= regular-string-char
  |  escape-sequence
  |  "\\u" { { DIGIT | UCHAR | LCHAR }+ }
  |  "\\newline" { "space" | "tab" }

// https://v2.ocaml.org/releases/4.14/htmlman/typedecl.html#ss:typedefs
type-definition ::= TYPE [NONREC] typedef { and_types }*

typedef ::= [type-params] type_name type-information

type_name ::= typeconstr-name

and_types ::= AND typedef

type-information ::= [type-equation] [type-representation] { type-constraint }*

type-equation ::= EQ typexpr

type-representation ::=
  EQ [PIPE] constr-decl { PIPE constr-decl }*
  | EQ record-decl
  | EQ PIPE

type-params ::= type-param
  |  LPAREN type-param { COMMA type-param } RPAREN

type-param ::= [ext-variance] SINGLE_QUOTE internal_ident

ext-variance ::= variance [injectivity]
  |  injectivity [variance]

variance ::= PLUS
  | MINUS

injectivity ::=  EXCLAMATION_MARK

record-decl ::= LBRACE field-decl { SEMI field-decl }* [SEMI] RBRACE

constr-decl ::= (constr-name | LBRACKET RBRACKET | LPAREN SHORTCUT RPAREN) [ OF constr-args ]

constr-args ::= typexpr { STAR typexpr }*

field-decl ::= [MUTABLE] field-name COLON poly-typexpr

type-constraint ::= CONSTRAINT typexpr EQ typexpr

// https://v2.ocaml.org/releases/4.14/htmlman/typedecl.html#ss:exndef
exception-definition ::= EXCEPTION constr-decl
  |  EXCEPTION constr-name EQ constr

// https://v2.ocaml.org/releases/4.14/htmlman/classes.html#ss:classes:class-types
class-type ::= [[QUESTION_MARK] label-name COLON] typexpr RIGHT_ARROW class-type
  |    class-body-type

class-body-type ::= OBJECT [( typexpr )] { class-field-spec } END
  | [[ typexpr { COMMA typexpr } ]] classtype-path
  | LET OPEN module-path IN class-body-type

class-field-spec ::= INHERIT class-body-type
  |   VAL [MUTABLE] [VIRTUAL] inst-var-name COLON typexpr
  |   VAL VIRTUAL MUTABLE inst-var-name COLON typexpr
  |   METHOD [PRIVATE] [VIRTUAL] method-name COLON poly-typexpr
  |   METHOD VIRTUAL PRIVATE method-name COLON poly-typexpr
  |   CONSTRAINT typexpr EQ typexpr

// https://v2.ocaml.org/releases/4.14/htmlman/classes.html#ss:class-expr
private internal_class-expr_rec ::= class-expr_terminal class-expr_non_terminal*

private class-expr_terminal ::= class-path
  | [ typexpr { COMMA typexpr } ] class-path
  | LPAREN class-expr RPAREN
  | LPAREN class-expr COLON class-type RPAREN
  | FUN { parameter }+ RIGHT_ARROW class-expr
  | LET [REC] let-binding { AND let-binding }* IN class-expr
  | OBJECT class-body END
  | LET OPEN module-path IN class-expr

private class-expr_non_terminal ::= internal_class-expr_rec { argument }+

class-expr ::= class-expr_terminal | class-expr_non_terminal

class-field ::= INHERIT class-expr [AS LOWERCASE_IDENT]
  |   INHERIT EXCLAMATION_MARK class-expr [AS LOWERCASE_IDENT]
  |   VAL [MUTABLE] inst-var-name [COLON typexpr] EQ expr
  |   VAL EXCLAMATION_MARK [MUTABLE] inst-var-name [COLON typexpr] EQ expr
  |   VAL [MUTABLE] VIRTUAL inst-var-name COLON typexpr
  |   VAL VIRTUAL MUTABLE inst-var-name COLON typexpr
  |   METHOD [PRIVATE] method-name { parameter }* [COLON typexpr] EQ expr
  |   METHOD EXCLAMATION_MARK [PRIVATE] method-name { parameter }* [COLON typexpr] EQ expr
  |   METHOD [PRIVATE] method-name COLON poly-typexpr EQ expr
  |   METHOD EXCLAMATION_MARK [PRIVATE] method-name COLON poly-typexpr EQ expr
  |   METHOD [PRIVATE] VIRTUAL method-name COLON poly-typexpr
  |   METHOD VIRTUAL PRIVATE method-name COLON poly-typexpr
  |   CONSTRAINT typexpr EQ typexpr
  |   INITIALIZER expr

// https://v2.ocaml.org/releases/4.14/htmlman/classes.html#sss:class-body
class-body ::=   [( pattern [COLON typexpr] )] { class-field }*

// https://v2.ocaml.org/releases/4.14/htmlman/classes.html#ss:class-def
class-definition ::= CLASS class-binding { AND class-binding }*

class-binding ::= [VIRTUAL] [[ type-parameters ]] class-name { parameter } [ COLON class-type] EQ class-expr

type-parameters ::= SINGLE_QUOTE internal_ident { COMMA SINGLE_QUOTE internal_ident }

// https://v2.ocaml.org/releases/4.14/htmlman/classes.html#ss:class-spec
class-specification ::= CLASS class-spec { AND class-spec }*

class-spec ::= [VIRTUAL] [[ type-parameters ]] class-name COLON class-type

// https://v2.ocaml.org/releases/4.14/htmlman/classes.html#ss:classtype
classtype-definition ::= CLASS TYPE classtype-def { AND classtype-def }*

classtype-def ::= [VIRTUAL] [[ type-parameters ]] class-name EQ class-body-type

// https://v2.ocaml.org/releases/4.14/htmlman/modtypes.html#s:modtypes
private internal_module-type_rec ::= module-type_terminal module-type_non_terminal*

private module-type_terminal ::= modtype-path
  |  SIG { specification [SEMISEMI] }* END
  |  FUNCTOR ( module-name COLON module-type ) RIGHT_ARROW module-type
  |  LPAREN module-type RPAREN

private module-type_non_terminal ::=
  internal_module-type_rec RIGHT_ARROW module-type
  | internal_module-type_rec WITH mod-constraint { AND mod-constraint }*

module-type ::= module-type_terminal | module-type_non_terminal

mod-constraint ::= TYPE [type-params] typeconstr type-equation { type-constraint }
  |  MODULE module-path EQ extended-module-path

specification ::= VAL value-name COLON typexpr
  | EXTERNAL value-name COLON typexpr EQ external-declaration
  | type-definition
  | EXCEPTION constr-decl
  | class-specification
  | classtype-definition
  | MODULE module-name COLON module-type
  | MODULE module-name { ( module-name COLON module-type ) }* COLON module-type
  | MODULE TYPE modtype-name
  | MODULE type modtype-name EQ module-type
  | open_stmt
  | INCLUDE module-type
  | recursive_module_extension_spec
  | generalized_open_statements_spec

// https://v2.ocaml.org/releases/4.14/htmlman/modules.html#s:module-expr
private internal_module-expr_rec ::= module-expr_terminal module-expr_non_terminal*

private module-expr_terminal ::= module-path
  |  STRUCT [ module-items ] END
  |  FUNCTOR ( module-name COLON module-type ) RIGHT_ARROW module-expr
  |  LPAREN module-expr RPAREN
  |  LPAREN module-expr COLON module-type RPAREN

private module-expr_non_terminal ::= internal_module-expr_rec ( module-expr )

module-expr ::= module-expr_terminal|module-expr_non_terminal

module-items ::= { SEMISEMI }* ( definition | expr ) { { SEMISEMI }* ( definition | SEMISEMI expr) }* { SEMISEMI }*

definition ::= LET [REC] let-binding { AND let-binding }*
  | EXTERNAL value-name COLON typexpr EQ external-declaration
  | type-definition
  | exception-definition
  | class-definition
  | classtype-definition
  | MODULE module-name { ( module-name COLON module-type ) }* [ COLON module-type ] EQ module-expr
  | MODULE TYPE modtype-name EQ module-type
  | open_stmt
  | INCLUDE module-expr
  | recursive_module_extension_def
  | generalized_open_statements_def

open_stmt ::= OPEN module-path {
  methods=[
    modulePath="/expr[1]"
  ]
}

external-declaration ::= string-literal [ string-literal [ string-literal ] ]

// https://v2.ocaml.org/releases/4.14/htmlman/recursivemodules.html#s%3Arecursive-modules
// todo: access to "and" modules is not generic
recursive_module_extension_def ::=
    MODULE REC module-name COLON module-type EQ module-expr { recursive_module_extension_def_and } *
    {
        implements = "com.ocaml.language.psi.api.OCamlModule"
    }

recursive_module_extension_def_and ::= AND module-name COLON module-type EQ module-expr
    {
        implements = "com.ocaml.language.psi.api.OCamlModule"
    }

recursive_module_extension_spec ::=
    MODULE REC module-name COLON module-type { recursive_module_extension_spec_and } *
    {
        implements = "com.ocaml.language.psi.api.OCamlModule"
        mixin = "com.ocaml.language.psi.mixin.OCamlModuleMixin"
    }

recursive_module_extension_spec_and ::= AND module-name COLON module-type
    {
        implements = "com.ocaml.language.psi.api.OCamlModule"
        mixin = "com.ocaml.language.psi.mixin.OCamlModuleMixin"
    }

// https://v2.ocaml.org/releases/4.14/htmlman/extensiblevariants.html#start-section

// https://v2.ocaml.org/releases/4.14/htmlman/generalizedopens.html#s:generalized-open
private generalized_open_statements_def ::=
  OPEN module-expr
  |   OPEN! module-expr

private generalized_open_statements_spec ::=
  OPEN extended-module-path
  | OPEN! extended-module-path

private generalized_open_statements_expr ::=
  LET OPEN module-expr IN expr
 | LET OPEN EXCLAMATION_MARK module-expr IN expr