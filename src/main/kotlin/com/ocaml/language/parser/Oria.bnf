{
  parserClass="com.ocaml.language.parser.OCamlParser"
  parserUtilClass="com.ocaml.language.parser.OCamlParserUtils"
  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="OCaml"
  psiImplClassSuffix="Impl"
  psiPackage="com.ocaml.language.psi"
  psiImplPackage="com.ocaml.language.psi.impl"
  psiImplUtilClass="com.ocaml.language.psi.OCamlImplUtils"

  generateTokens=true
  generateTokenAccessors=false

  elementTypeHolderClass="com.ocaml.language.psi.OCamlTypes"
  elementTypeClass="com.ocaml.language.psi.api.OCamlElementType"
  tokenTypeClass="com.ocaml.language.psi.api.OCamlTokenType"

  tokens = [
          AND = "and"
          AS = "as"
          ASSERT = "assert"
          BEGIN = "begin"
          CLASS = "class"
          CONSTRAINT = "constraint"
          DO = "do"
          DONE = "done"
          DOWNTO = "downto"
          ELSE = "else"
          END = "end"
          EXCEPTION = "exception"
          EXTERNAL = "external"
          FOR = "for"
          FUN = "fun"
          FUNCTION = "function"
          FUNCTOR = "functor"
          IF = "if"
          IN = "in"
          INCLUDE = "include"
          INHERIT = "inherit"
          INITIALIZER = "initializer"
          LAZY = "lazy"
          LET = "let"
          MODULE = "module"
          MUTABLE = "mutable"
          NEW = "new"
          NONREC = "nonrec"
          OBJECT = "object"
          OF = "of"
          OPEN = "open"
          OR = "or"
          REC = "rec"
          SIG = "sig"
          STRUCT = "struct"
          THEN = "then"
          TO = "to"
          TRY = "try"
          TYPE = "type"
          VAL = "val"
          VIRTUAL = "virtual"
          WHEN = "when"
          WHILE = "while"
          WITH = "with"
          LBRACELESS = "{<"
          GREATERRBRACE = ">}"

          MOD = "mod"
          LAND = "land"
          LOR = "lor"
          LXOR = "lxor"
          LSL = "lsl"
          LSR = "lsr"
          ASR = "asr"

          TRUE = "true"
          FALSE = "false"

          METHOD = "method"
          PRIVATE = "private"
          MATCH = "match"

          UNDERSCORE = "_"

          SHORTCUT = "::"
          RIGHT_ARROW = "->"
          LEFT_ARROW = "<-"
          LARRAY = "[|"
          RARRAY = "|]"

          EQ = "="
          NOT_EQ = "!="
          COLON_EQ = ":="
          COLON_GT = ":>"
          SEMISEMI = ";;"
          L_OR = "||"
          L_AND = "&&"

          CARRET = "^"
          MINUSDOT = "-."
          PLUSEQ = "+="
          PLUS = "+"
          MINUS = "-"
          SLASH = "/"
          STAR = "*"

          COMMA = ","
          COLON = ":"
          SEMI = ";"
          SINGLE_QUOTE = "'"
          DOTDOT = ".."
          DOT = "."
          PIPE = "|"
          LPAREN = "("
          RPAREN = ")"
          LBRACE = "{"
          RBRACE = "}"
          LBRACKET = "["
          RBRACKET = "]"
          ARROBASE = "@"
          SHARP = "#"
          QUESTION_MARK = "?"
          EXCLAMATION_MARK = "!"
          DOLLAR = "$"
          BACKTICK = "`"
          TILDE = "~"
          AMPERSAND = "&"

          PERCENT = "%"

          LT = "<"
          GT = ">"

          LBRACKETGREATER = "[>"
          LBRACKETLESS = "[<"

          COMMENT = "COMMENT"
          DOC_COMMENT = "DOC_COMMENT"
    ]

  extends(".*pattern_no_exn")=pattern_no_exn
  extends(".*pattern_expression")=pattern_expression
  extends("coloncolon_app_rule|label_assign_expr|ref_read_bin_expr|infixop4_bin_expr|infixop5_bin_expr|ref_assign_bin_expr|sign_unary_expr|mul_bin_expr|div_bin_expr|raise_expr|sum_bin_expr|infixop1_bin_expr|and_bin_expr|or_bin_expr|compare_bin_expr|coloncolon_bin_expr|expr_comma_list|non_op_expr|expr")=expr
  extends("first_class_module_expr|sharpop_expr|.*_object_expr|.*_with_local_open_expr|bang_expr|list_constructor_expr|array_constructor_expr|.*_assign_expr|.*_lookup_expr|record_constructor_expr|sharp_op_expr|non_op_simple_expr|simple_expr")=simple_expr
}

// ALL MAJOR TODOS
// todo:  aliases are not handled

/*Copyright (c) 2021 Sidharth Kuruvila
Implicit reference: https://v2.ocaml.org/manual/lex.html.
Implicit reference: https://docs.ocaml.pro/sources/merlin.3.4.2/upstream/ocaml_402/parsing/parser.mly/index.html
*/
/* Entry points */
file ::= COMMENT
| DOC_COMMENT
| ANNOTATION
//| unit-interface
| unit-implementation

// INTERNAL TOKENS THAT WERE NOT IN THE  DOCUMENTATION
// otherwise lowercase and capitalized are not recognized as ident
ident ::= CAPITALIZED_IDENT | LOWERCASE_IDENT

// These operators are considered as one character
private lexed_operators ::= MINUSDOT | PLUSEQ | L_OR | L_AND | NOT_EQ
| COLON_EQ

// https://v2.ocaml.org/releases/4.14/htmlman/compunit.html#start-section
unit-implementation ::= [ module-items ]
//unit-interface ::=  { specification [SEMISEMI] }+

// https://v2.ocaml.org/releases/4.14/htmlman/lex.html#sss:integer-literals

// https://v2.ocaml.org/releases/4.14/htmlman/lex.html#sss:floating-point-literals

// https://v2.ocaml.org/releases/4.14/htmlman/lex.html#sss:character-literals

// https://v2.ocaml.org/releases/4.14/htmlman/lex.html#sss:stringliterals

// https://v2.ocaml.org/releases/4.14/htmlman/lex.html#sss:labelname
label_name ::= LOWERCASE_IDENT
// these two were unused, dunno why
// label ::=  TILDE label_name COLON
// optlabel ::=  QUESTION_MARK label_name COLON

// https://v2.ocaml.org/releases/4.14/htmlman/lex.html#sss:lex-ops-symbols
infix_symbol ::= (core_operator_char | PERCENT | LT) { operator_char }*
  | SHARP { operator_char }+

prefix_symbol ::= EXCLAMATION_MARK { operator_char }*
  | (QUESTION_MARK | TILDE) { operator_char }+

operator_char ::= TILDE | EXCLAMATION_MARK | QUESTION_MARK | core_operator_char | PERCENT | LT | COLON | DOT
| lexed_operators

core_operator_char ::= DOLLAR | AMPERSAND | STAR | PLUS | MINUS | SLASH | EQ | GT | ARROBASE | CARRET | PIPE

//linenum-directive ::= SHARP { DIGIT }+ '"' { string-character } '"'

// https://v2.ocaml.org/releases/4.14/htmlman/names.html#sss:naming-objects
// [CHANGES]: raise can be used as an identifier (value_name)
value_name ::= LOWERCASE_IDENT
  | LPAREN operator_name RPAREN

operator_name ::= prefix_symbol | infix_op

infix_op ::= infix_symbol
  |  STAR | PLUS | MINUS | MINUSDOT | EQ | NOT_EQ | LT | GT | OR | L_OR | AMPERSAND | L_AND | COLON_EQ
  |  MOD | LAND | LOR | LXOR | LSL | LSR | ASR

constr_name ::= CAPITALIZED_IDENT

typeconstr_name ::= LOWERCASE_IDENT

field_name ::= LOWERCASE_IDENT

// [BACK]: was UIDENT | UNDERSCORE
module_name ::= CAPITALIZED_IDENT

modtype_name ::= ident

class_name ::= LOWERCASE_IDENT

inst_var_name ::= LOWERCASE_IDENT

method_name ::= LOWERCASE_IDENT

// https://v2.ocaml.org/releases/4.14/htmlman/names.html#sss:refer-named
constr ::= [ module_path DOT ] constr_name

typeconstr ::= [ extended_module_path DOT ] typeconstr_name

// [BACK]: was ident (DOT ident) *
modtype_path ::= [ extended_module_path DOT ] modtype_name

classtype_path ::= [ extended_module_path DOT ] class_name

module_path ::= module_name { DOT module_name }*

extended_module_path ::= extended_module_name { DOT extended_module_name }*

extended_module_name ::= module_name { LPAREN extended_module_path RPAREN }*

// https://v2.ocaml.org/releases/4.14/htmlman/types.html#s:typexpr
// todo: major element not OK
typexpr ::= typexpr_no_attr
// 4.b. handle RIGHT_ARROW with no label
// 7. handle as SINGLE_QUOTE ident
private typexpr_no_attr ::=
    { typexpr2 { RIGHT_ARROW typexpr2 }+ | typexpr2 } [AS SINGLE_QUOTE ident]

// 4.a. handle RIGHT_ARROW with label
// [BETS]: Removed: "| OPTLABEL typexpr2" and "| LOWERCASE_IDENT COLON typexpr2"
private typexpr2 ::=
    [QUESTION_MARK] label_name COLON typexpr2
  | simple_typeexpr_or_tuple

// 5. Handle tuples
private simple_typeexpr_or_tuple ::=
    simple_typeexpr [ STAR simple_typeexpr { STAR simple_typeexpr }* ]

// Not sure which one is handled here
private simple_typeexpr ::=
    simple_typeexpr2 { simple_typeexpr2_suffix } *
  | LPAREN typexpr { COMMA typexpr }* RPAREN

private simple_typeexpr2_suffix ::=
    SHARP class_longident
    | type_longident

private simple_typeexpr2 ::=
    SINGLE_QUOTE ident (DOT SINGLE_QUOTE ident)?
  | UNDERSCORE
  | type_longident
  | LPAREN typexpr { COMMA typexpr }* RPAREN type_longident
  // [CHANGES]: uncommented all
  | LT meth_list GT
  | LT GT
  | SHARP class_longident
  | LPAREN typexpr { COMMA typexpr }* RPAREN SHARP class_longident
  | LBRACKET tag_field RBRACKET
/* PR#3835: this is not LR(1), would need lookahead=2
  | LBRACKET simple_core_type RBRACKET
*/
  | LBRACKET PIPE? row_field_list RBRACKET
  | LBRACKETGREATER row_field_list RBRACKET
  | LBRACKETLESS row_field_list RBRACKET
//  | LBRACKETGREATER PIPE ? row_field_list RBRACKET
  | LBRACKETGREATER RBRACKET
//  | LBRACKETLESS PIPE ? row_field_list RBRACKET
//  | LBRACKETLESS PIPE ? row_field_list GT name_tag_list RBRACKET
  | LPAREN MODULE package_type RPAREN

// https://v2.ocaml.org/releases/4.14/htmlman/types.html#sss:typexpr-polyvar

// https://v2.ocaml.org/releases/4.14/htmlman/const.html#s:const

// https://v2.ocaml.org/releases/4.14/htmlman/patterns.html#s:patterns

// https://v2.ocaml.org/releases/4.14/htmlman/expr.html#s:value-expr

// https://v2.ocaml.org/releases/4.14/htmlman/typedecl.html#ss:typedefs
type_definition ::= TYPE [NONREC] typedef { AND typedef }*

// [BETS]: used type_params instead of optional_type_parameters
typedef ::= [type_params] typeconstr_name type_information

type_information ::= [type_equation] [type_representation] { type_constraint }*

// [BETS]: removed a bunch of stuff with private opt
type_equation ::= EQ typexpr
| private_type_equation

type_representation ::=
    EQ [PIPE] constr_decl { PIPE constr_decl } *
  | EQ record_decl
  | EQ PIPE
  | private_type_representation
  | type_extension_representation

type_params ::= type_param
  |  LPAREN type_param { COMMA type_param }* RPAREN

type_param ::= [ext_variance] SINGLE_QUOTE ident
//optional_type_param ::= [ext_variance] (SINGLE_QUOTE ident|UNDERSCORE)

ext_variance ::= variance [injectivity]
  |  injectivity [variance]

variance ::= PLUS | MINUS

injectivity ::= EXCLAMATION_MARK

record_decl ::= LBRACE field_decl { SEMI field_decl }* [SEMI] RBRACE

// fixme: constr_decl doesn't support ":" (see: https://v2.ocaml.org/releases/4.14/htmlman/gadts.html#s:gadts)
// [BEST]: removed from first LPAREN RPAREN (unit) and true|false
// [BEST]: removed "| COLON constr_args RIGHT_ARROW simple_core_type"
// [BEST]: removed "| COLON simple_core_type"
constr_decl ::= (constr_name | LBRACKET RBRACKET | LPAREN SHORTCUT RPAREN) [OF constr_args]

// [MAJOR]: used simple_typeexpr
constr_args ::= simple_typeexpr { STAR simple_typeexpr } *
| inline_records_constr_args

field_decl ::= [MUTABLE] field_name COLON poly_type_no_attr // todo

type_constraint ::= CONSTRAINT typexpr EQ typexpr

// https://v2.ocaml.org/releases/4.14/htmlman/typedecl.html#ss:exndef
exception_definition ::= EXCEPTION constr_name EQ constr
| exception_specification

exception_specification ::= EXCEPTION constr_decl

// https://v2.ocaml.org/releases/4.14/htmlman/classes.html#ss:classes:class-types
// [MAJOR]: using simple_core_type_or_tuple
// [BETS]: using RAW opt label
// [OPT]: go back to two lines?
class_type ::=
  QUESTION_MARK LOWERCASE_IDENT COLON simple_typeexpr_or_tuple RIGHT_ARROW class_type
  | LOWERCASE_IDENT COLON simple_typeexpr_or_tuple RIGHT_ARROW class_type
  | simple_typeexpr_or_tuple RIGHT_ARROW class_type
  | class_body_type

class_body_type ::=
    OBJECT [LPAREN typexpr RPAREN] { class_field_spec } * END
    | LBRACKET typexpr { COMMA typexpr } * RBRACKET classtype_path
    | LET OPEN module_path IN class_body_type

class_field_spec ::=
    INHERIT class_body_type
  | VAL [MUTABLE] [VIRTUAL] inst_var_name COLON typexpr
  | VAL VIRTUAL MUTABLE inst_var_name COLON typexpr
  | METHOD [PRIVATE] [VIRTUAL] method_name EQ poly_type // todo
  | METHOD VIRTUAL PRIVATE method_name EQ poly_type
  | CONSTRAINT typexpr EQ typexpr

// https://v2.ocaml.org/releases/4.14/htmlman/classes.html#ss:class-expr
// todo
class_expr ::=
    class_simple_expr { simple_expr | label_expr } *
  | class_simple_expr
  | FUN class_fun_def
  | let_bindings IN class_expr

private class_simple_expr ::=
    LBRACKET typexpr { COMMA typexpr } * RBRACKET class_longident
  | class_longident
  | OBJECT class_structure ? END
  | LPAREN class_expr COLON class_type RPAREN
  | LPAREN class_expr RPAREN

class_field ::=
  INHERIT [EXCLAMATION_MARK] class_expr [AS LOWERCASE_IDENT]
  | VAL value
  | METHOD method_
  | CONSTRAINT constrain_field
  | INITIALIZER seq_expr

private method_ ::=
    [EXCLAMATION_MARK] PRIVATE VIRTUAL label COLON poly_type
  | [EXCLAMATION_MARK] VIRTUAL PRIVATE ? label COLON poly_type
  | [EXCLAMATION_MARK] PRIVATE ? label strict_binding
  | [EXCLAMATION_MARK] PRIVATE ? label COLON poly_type EQ seq_expr
  | [EXCLAMATION_MARK] PRIVATE ? label COLON TYPE lident_list
    DOT core_type EQ seq_expr

private value ::=
    [EXCLAMATION_MARK] MUTABLE VIRTUAL label COLON core_type
  | [EXCLAMATION_MARK] VIRTUAL MUTABLE ? label COLON core_type
  | [EXCLAMATION_MARK] MUTABLE ? label EQ seq_expr
  | [EXCLAMATION_MARK] MUTABLE ? label type_constraint_stro EQ seq_expr

// https://v2.ocaml.org/releases/4.14/htmlman/classes.html#sss:class-body

// https://v2.ocaml.org/releases/4.14/htmlman/classes.html#ss:class-def
class_definition ::= CLASS class_binding { AND class_binding } *

class_binding ::=
    [VIRTUAL] [class_type_parameters] class_name { labeled_simple_pattern }* // todo
    [COLON class_type] EQ class_expr

private class_type_parameters ::= LBRACKET type_parameters RBRACKET
type_parameters ::= SINGLE_QUOTE ident { COMMA SINGLE_QUOTE ident }*

// https://v2.ocaml.org/releases/4.14/htmlman/classes.html#ss:class-spec
class_specification ::= CLASS class_spec { AND class_spec } *
class_spec ::= [VIRTUAL] [class_type_parameters] class_name COLON class_type

// https://v2.ocaml.org/releases/4.14/htmlman/classes.html#ss:classtype
classtype_definition ::= CLASS TYPE classtype_def { AND classtype_def } *
classtype_def ::= [VIRTUAL] [class_type_parameters] class_name EQ class_body_type

// https://v2.ocaml.org/releases/4.14/htmlman/modtypes.html#s:modtypes
private base_module_type ::= modtype_path
  | SIG [SEMISEMI] { specification [SEMISEMI] }* END // added [SEMISEMI]
  | FUNCTOR LPAREN module_name COLON module_type RPAREN RIGHT_ARROW module_type
  | LPAREN module_type RPAREN
  | module_type_typeof

private module_type_suffix ::=
    RIGHT_ARROW module_type
    | WITH mod_constraint { AND mod_constraint }*

module_type ::= base_module_type [module_type_suffix]

// [BETS]: replaced previous names/paths with others
mod_constraint ::=
    TYPE [type_params] typeconstr type_equation { type_constraint }*
  | MODULE module_path EQ extended_module_path
  | signature_substitution_mod_constraint

// [BETS]: removed module_alias ::= MODULE (CAPITALIZED_IDENT|UNDERSCORE) EQ mod_longident
specification ::=
    value_description
  | type_definition
  | exception_specification
  | class_specification
  | classtype_definition
  | module_declaration
  | module_type_declaration
  | open_statement
  | sig_include_statement
  // extensions
  | type_extension_definition
  | recursive_module_extension_spec
  | module_alias_spec
  | signature_substitution_spec
  // special
  | primitive_declaration

private value_description ::= VAL value_name COLON typexpr

private module_declaration ::=
    MODULE module_name COLON module_type
  | MODULE module_name LPAREN module_name COLON module_type RPAREN COLON module_type

private module_type_declaration ::=
    MODULE TYPE modtype_name
    | MODULE TYPE modtype_name EQ module_type

private open_statement ::= OPEN module_path

private sig_include_statement ::= INCLUDE module_type

// https://v2.ocaml.org/releases/4.14/htmlman/modules.html#s:module-expr
module-items ::= // todo: seq_expr and fixme: definition|specification
{ SEMISEMI }* (definition|specification|seq_expr)? { { SEMISEMI }* ( definition | specification | SEMISEMI seq_expr) }* { SEMISEMI }*

// todo
definition ::=
    let_bindings
  | type_definition
  | exception_definition
  | module_binding
  | module_type_declaration
  | open_statement
  | class_definition
  | classtype_definition
  | str_include_statement
  // extensions
  | type_extension_specification
  | recursive_module_extension_def
  // special
  | primitive_declaration

// https://v2.ocaml.org/releases/4.14/htmlman/intfc.html#s:c-overview
primitive_declaration ::=
    EXTERNAL value_name COLON typexpr EQ external_declaration

external_declaration ::= STRING_VALUE [ STRING_VALUE [ STRING_VALUE ] ]

// https://v2.ocaml.org/releases/4.14/htmlman/recursivemodules.html#s:recursive-modules
// [BETS]: discard rec_module_bindings ; rec_module_binding ; and_module_binding
private recursive_module_extension_def ::=
    MODULE REC module_name COLON module_type EQ module_expr
    { AND module_name COLON module_type EQ module_expr } *

private recursive_module_extension_spec ::=
    MODULE REC module_name COLON module_type { AND module_name COLON module_type } *

// https://v2.ocaml.org/releases/4.14/htmlman/generalizedopens.html#s:generalized-open

// https://v2.ocaml.org/releases/4.14/htmlman/extensiblevariants.html
private type_extension_representation ::= EQ DOTDOT
| PRIVATE EQ DOTDOT

// [BETS]: removed [NONREC]
// [BETS]: removed optional_type_parameters
// [BETS]: removed type_longident and used typeconstr
private type_extension_specification ::= TYPE [type_params] typeconstr type_extension_spec
private type_extension_definition ::= TYPE [type_params] typeconstr type_extension_def

type_extension_spec ::= PLUSEQ [PRIVATE] [PIPE] constr_decl { PIPE constr_decl } *
type_extension_def ::= PLUSEQ [PRIVATE] [PIPE] constr_def { PIPE constr_def } *

// [BETS]: used 'constr_name' instead of '... | () | [] | true | false'
// [BETS]: used 'constr' instead of '... | () | [] | true | false'
constr_def ::= constr_decl | constr_name EQ constr

// https://v2.ocaml.org/releases/4.14/htmlman/moduletypeof.html#s:module-type-of
private module_type_typeof ::= MODULE TYPE OF module_expr

// (3/3) https://v2.ocaml.org/releases/4.14/htmlman/privatetypes.html#s:private-types
private private_type_equation ::= EQ PRIVATE typexpr

private private_type_representation ::=
    EQ PRIVATE [PIPE] constr_decl { PIPE constr_decl } *
  | EQ PRIVATE record_decl
  | EQ PRIVATE PIPE

// (1/1) https://v2.ocaml.org/releases/4.14/htmlman/modulealias.html#s:module-alias
private module_alias_spec ::= MODULE module_name EQ module_path

// (1/1) https://v2.ocaml.org/releases/4.14/htmlman/signaturesubstitution.html#s:signature-substitution
private signature_substitution_mod_constraint ::=
    TYPE [type_params] typeconstr_name COLON_EQ typexpr
    | MODULE module_path COLON_EQ extended_module_path
    | MODULE TYPE modtype_path EQ module_type
    | MODULE TYPE modtype_path COLON_EQ module_type

private signature_substitution_spec ::=
    TYPE type_subst { AND type_subst }*
    | MODULE module_name COLON_EQ extended_module_path
    | MODULE TYPE module_name COLON_EQ module_type

type_subst ::= [type_params] typeconstr_name COLON_EQ typexpr { type_constraint }*

// (1/1) https://v2.ocaml.org/releases/4.14/htmlman/inlinerecords.html#s:inline-records
private inline_records_constr_args ::= record_decl






// [CHANGE]: added all 4 below
private INFIXOP3 ::= LOR | LXOR | MOD | LAND
private INFIXOP4 ::= LSL | LSR | ASR
private INFIXOP5 ::= PIPE GT | CARRET | CARRET CARRET | ARROBASE | ARROBASE ARROBASE
BOOL_VALUE ::= TRUE | FALSE

functor_arg ::=
    LPAREN RPAREN
  | LPAREN functor_arg_name COLON module_type RPAREN

functor_arg_name ::=
    CAPITALIZED_IDENT
  | UNDERSCORE

functor_args ::=
    functor_arg +

module_expr_sufix ::=
    (LPAREN module_expr RPAREN | LPAREN RPAREN | module_expr attribute) +

module_expr ::=
    mod_longident module_expr_sufix?
  | STRUCT module-items END module_expr_sufix?
  | FUNCTOR functor_args RIGHT_ARROW module_expr module_expr_sufix?
  | LPAREN module_expr COLON module_type RPAREN
  | LPAREN module_expr RPAREN
  | LPAREN VAL expr RPAREN
  | LPAREN VAL expr COLON package_type RPAREN
  | LPAREN VAL expr COLON package_type COLON_GT package_type
    RPAREN
  | LPAREN VAL expr COLON_GT package_type RPAREN
  | extension

str_include_statement ::=
    INCLUDE module_expr

// [CHANGES]: using (EQ module_expr)?
module_binding_body ::=
    EQ module_expr
  | COLON module_type (EQ module_expr)?
  | functor_arg module_binding_body

module_binding ::=
    MODULE (CAPITALIZED_IDENT|UNDERSCORE) module_binding_body
///* Class expressions */

class_fun_def ::=
    labeled_simple_pattern + RIGHT_ARROW class_expr

//
class_structure ::=
   class_self_pattern ? class_fields ?
//
//
class_self_pattern ::=
    LPAREN pattern_expression RPAREN
  | LPAREN pattern_expression COLON core_type RPAREN


class_fields ::=
    class_field +

///* Class types */


constrain_field ::=
        core_type EQ core_type

///* Core expressions */
//
seq_expr ::= expr (SEMI expr)*  SEMI ? //%prec below_SEMI

labeled_simple_pattern ::=
    QUESTION_MARK LPAREN label_let_pattern opt_default ? RPAREN
  | QUESTION_MARK label_var
  | OPTLABEL LPAREN let_pattern opt_default ? RPAREN
  | OPTLABEL pattern_var
  | TILDE LPAREN label_let_pattern RPAREN
  | TILDE label_var
  | LABEL_OP simple_pattern
  | simple_pattern

pattern_var ::=
    LOWERCASE_IDENT
  | UNDERSCORE

opt_default ::=
    EQ seq_expr

label_let_pattern ::=
    label_var (COLON core_type)?

label_var ::=
    LOWERCASE_IDENT

let_pattern ::=
    pattern_expression (COLON core_type) ?


//  %nonassoc IN
//  %nonassoc below_SEMI
//  %nonassoc SEMI                          /* below EQ ({lbl=...; lbl=...}) */
//  %nonassoc LET                           /* above SEMI ( ...; let ... in ...) */
//  %nonassoc below_WITH
//  %nonassoc FUNCTION WITH                 /* below PIPE  (match ... with ...) */
//  %nonassoc AND             /* above WITH (module rec A: SIG with ... and ...) */
//  %nonassoc THEN                          /* below ELSE (if ... then ...) */
//  %nonassoc ELSE                          /* (if ... then ... else ...) */
//  %nonassoc LESSMINUS                     /* below COLON_EQ (lbl <- x := e) */
//  %right    COLON_EQ                    /* expr (e := e := e) */
//  %nonassoc AS
//  %left     PIPE                           /* pattern (p|p|p) */
//  %nonassoc below_COMMA
//  %left     COMMA                         /* expr/expr_comma_list (e,e,e) */
//  %right    RIGHT_ARROW                  /* core_type2 (t -> t -> t) */
//  %right    OR L_OR                     /* expr (e || e || e) */
//  %right    AMPERSAND L_AND          /* expr (e && e && e) */
//  %nonassoc below_EQUAL
//  %left     NOT_EQ EQ LT GT   /* expr (e OP e OP e) */
//  %right    INFIXOP1                      /* expr (e OP e OP e) */
//  %nonassoc below_LBRACKETAT
//  %nonassoc LBRACKETAT
//  %nonassoc LBRACKETATAT
//  %right    SHORTCUT                    /* expr (e :: e :: e) */
//  %left     INFIXOP2 PLUS PLUSDOT MINUS MINUSDOT PLUSEQ /* expr (e OP e OP e) */
//  %left     PERCENT INFIXOP3 STAR                 /* expr (e OP e OP e) */
//  %right    INFIXOP4                      /* expr (e OP e OP e) */
//  %nonassoc prec_unary_minus prec_unary_plus /* unary - */
//  %nonassoc prec_constant_constructor     /* cf. simple_expr (C versus C x) */
//  %nonassoc prec_constr_appl              /* above AS PIPE SHORTCUT COMMA */
//  %nonassoc below_SHARP
//  %nonassoc SHARP                         /* simple_expr/toplevel_directive */
//  %left     SHARPOP
//  %nonassoc below_DOT
//  %nonassoc DOT
//  /* Finally, the first tokens of simple_expr are above everything else. */
//  %nonassoc BACKQUOTE EXCLAMATION_MARK BEGIN CHAR_VALUE FALSE FLOAT_VALUE INTEGER_VALUE
//            LBRACE LBRACELESS LBRACKET LARRAY LOWERCASE_IDENT LPAREN
//            NEW STRING_VALUE TRUE CAPITALIZED_IDENT
//            LBRACKETPERCENT LBRACKETPERCENTPERCENT
expr ::=
    coloncolon_app_rule
  | expr_comma_list //%prec below_COMMA
  | non_op_expr
  | ref_read_bin_expr
  | or_bin_expr
  | and_bin_expr
  | compare_bin_expr
  | infixop1_bin_expr
  | coloncolon_bin_expr
  | sum_bin_expr
  | mul_bin_expr
  | infixop4_bin_expr
  | infixop5_bin_expr
  | sign_unary_expr
  // [CHANGES]: added new entry
  | div_bin_expr
  | raise_expr
//  | expr attribute
//
//  | UNDERSCORE
//
//

assert_expr ::= ASSERT simple_expr //%prec below_SHARP

while_expr ::= WHILE seq_expr DO seq_expr DONE

non_op_expr ::=
    let_bindings IN seq_expr
  | LET MODULE CAPITALIZED_IDENT module_binding_body IN seq_expr
  | LET EXCEPTION constr_ident generalized_constructor_arguments ? IN seq_expr
  | LET OPEN [EXCLAMATION_MARK] module_path_stro IN seq_expr
  | FUNCTION PIPE ? match_cases
  | FUN labeled_simple_pattern fun_def
  | FUN LPAREN TYPE lident_list RPAREN fun_def
  | MATCH seq_expr WITH PIPE ? match_cases
  | TRY seq_expr WITH PIPE ? match_cases
  | constr_longident simple_expr //%prec below_SHARP
  | name_tag simple_expr //%prec below_SHARP
  | if_else_expr
//  | IF ext_attributes ? seq_expr THEN expr
  | while_expr
  | FOR pattern_expression EQ seq_expr direction_flag seq_expr DO seq_expr DONE
  | label_assign_expr
  | assert_expr
  | LAZY simple_expr //%prec below_SHARP
  | OBJECT class_structure ? END
  | simple_expr labeled_simple_expr *
  | simple_expr //%prec below_SHARP

coloncolon_app_rule ::=
    LPAREN SHORTCUT RPAREN LPAREN expr RPAREN

if_else_condition ::= seq_expr
then_expr ::= expr
else_expr ::= expr

if_else_expr ::=
    IF if_else_condition THEN then_expr (ELSE else_expr) ?

ref_read_bin_expr ::=
    expr COLON_EQ expr { rightAssociative = true }

coloncolon_bin_expr ::=
    expr SHORTCUT expr { rightAssociative = true }

// [CHANGE]: added EQEQ OP_STRUCT_DIFF LT_OR_EQUAL GT_OR_EQUAL
compare_bin_expr ::=
    expr (NOT_EQ | EQ | EQEQ | OP_STRUCT_DIFF | LT | GT | LT_OR_EQUAL | GT_OR_EQUAL) expr

or_bin_expr ::=
  expr (OR | L_OR) expr { rightAssociative = true }

and_bin_expr ::=
  expr (AMPERSAND | L_AND) expr { rightAssociative = true }

infixop1_bin_expr ::=
    expr INFIXOP1 expr

sum_bin_expr ::=
    expr (INFIXOP2 | PLUS | PLUSDOT | MINUS | MINUSDOT) expr

mul_bin_expr ::=
    expr (INFIXOP3 | STAR | STARDOT | STARSTAR | PERCENT) expr

// [CHANGES]: added div_bin_expr, raise_expr
div_bin_expr ::=
    expr (SLASH | SLASHDOT) expr

raise_expr ::=
    RAISE expr

infixop4_bin_expr ::=
    expr INFIXOP4 expr  { rightAssociative = true }

infixop5_bin_expr ::=
    expr INFIXOP5 expr  { rightAssociative = true }

// [CHANGE]: "~+." is the same as "+." (etc.)
sign_unary_expr ::=
    (subtractive | additive) expr

simple_expr ::=
    local_open_group
  | non_op_simple_expr
  | record_constructor_expr
  | assign_expr
  | lookup_expr
  | array_constructor_expr
  | list_constructor_expr
  | bang_expr
  | new_object_expr
  | self_copy_object_expr
  | send_message_object_expr
  | sharpop_expr
  | first_class_module_expr

first_class_module_expr ::=
    LPAREN MODULE module_expr (COLON package_type) ? RPAREN

private local_open_group ::=
      object_copy_with_local_open_expr
    | expr_with_local_open_expr
    | list_constructor_with_local_open_expr
    | array_constructor_with_local_open_expr
    | record_constructor_with_local_open_expr
    | first_class_module_with_local_open_expr

first_class_module_with_local_open_expr ::=
    mod_longident DOT LPAREN MODULE module_expr COLON package_type RPAREN

record_constructor_with_local_open_expr ::=
    mod_longident DOT LBRACE record_expr RBRACE

object_copy_with_local_open_expr ::=
    mod_longident DOT LBRACELESS field_expr_list ? GREATERRBRACE

expr_with_local_open_expr ::=
   mod_longident DOT LPAREN seq_expr RPAREN

list_constructor_with_local_open_expr ::=
   mod_longident DOT LBRACKET expr_semi_list SEMI ? RBRACKET

array_constructor_with_local_open_expr ::=
    mod_longident DOT LARRAY ( expr_semi_list SEMI ? )? RARRAY


non_op_simple_expr ::=
    val_longident
  | constant
  | constr_longident //%prec prec_constant_constructor
  | name_tag //%prec prec_constant_constructor
  | LPAREN seq_expr RPAREN
  | BEGIN seq_expr ? END
  | LPAREN seq_expr type_constraint_stro RPAREN

private lookup_expr ::=
    field_lookup_expr
  | array_lookup_expr
  | string_lookup_expr
  | bigarray_lookup_expr


private assign_expr ::=
    field_assign_expr
  | array_assign_expr
  | string_assign_expr
  | bigarray_assign_expr

bang_expr ::=
    EXCLAMATION_MARK simple_expr

new_object_expr ::=
    NEW class_longident

self_copy_object_expr ::=
    LBRACELESS field_expr_list ? GREATERRBRACE

send_message_object_expr ::=
    simple_expr SHARP label

array_constructor_expr ::=
  LARRAY (expr_semi_list SEMI ?) ? RARRAY

list_constructor_expr ::=
    LBRACKET expr_semi_list SEMI ? RBRACKET

field_lookup_expr ::=
    simple_expr DOT label_longident

field_assign_expr ::=
    simple_expr DOT label_longident assignment

array_lookup_expr ::=
    simple_expr DOT LPAREN seq_expr RPAREN

array_assign_expr ::=
    simple_expr DOT LPAREN seq_expr RPAREN assignment


string_lookup_expr ::=
  simple_expr DOT LBRACKET seq_expr RBRACKET

string_assign_expr ::=
    simple_expr DOT LBRACKET seq_expr RBRACKET assignment

bigarray_lookup_expr ::=
  simple_expr DOT LBRACE expr RBRACE

bigarray_assign_expr ::=
    simple_expr DOT LBRACE expr RBRACE assignment

assignment ::=
    LESSMINUS expr

label_assign_expr ::=
    label LESSMINUS expr

record_constructor_expr ::=
    LBRACE record_expr RBRACE


sharpop_expr ::= simple_expr SHARPOP simple_expr

labeled_simple_expr ::=
    simple_expr | label_expr


label_expr ::=
    LABEL_OP simple_expr //%prec below_SHARP
  | TILDE label_ident
  | QUESTION_MARK label_ident
  | OPTLABEL simple_expr //%prec below_SHARP

label_ident ::=
    LOWERCASE_IDENT

lident_list ::=
    LOWERCASE_IDENT +

val_decl ::= value_name

// [CHANGES]: added let_binding_expr
let_binding_body_expr ::= seq_expr

private internal_let_binding_body ::=
    val_decl fun_binding
  | value_name COLON typevar_list DOT core_type EQ let_binding_body_expr
  | value_name COLON TYPE lident_list DOT core_type EQ let_binding_body_expr
  | pattern_no_exn EQ let_binding_body_expr
  | simple_pattern_not_ident COLON core_type EQ let_binding_body_expr

let_binding_body ::= internal_let_binding_body

let_bindings ::= let_binding and_let_binding *

// [CHANGE]: added attributes after body ([@])
let_binding ::=
    LET REC ? let_binding_body

and_let_binding ::=
    AND let_binding_body
//
//
fun_binding ::=
    strict_binding
  | type_constraint_stro EQ let_binding_body_expr

strict_binding ::=
    EQ let_binding_body_expr
  | labeled_simple_pattern fun_binding
  | LPAREN TYPE lident_list RPAREN fun_binding

match_cases ::=
    match_case (PIPE match_case) *

match_case ::=
    pattern_expression RIGHT_ARROW seq_expr
  | pattern_expression WHEN seq_expr RIGHT_ARROW seq_expr
  | pattern_expression RIGHT_ARROW DOT


fun_def ::=
    RIGHT_ARROW seq_expr
  | COLON simple_core_type RIGHT_ARROW seq_expr
/* Cf #5939: we used to accept (fun p when e0 -> e) */
  | labeled_simple_pattern fun_def
  | LPAREN TYPE lident_list RPAREN fun_def


expr_comma_list ::=
    expr (COMMA expr) +

record_expr ::=
    simple_expr WITH lbl_expr_list
  | lbl_expr_list
//
lbl_expr_list ::=
    lbl_expr (SEMI lbl_expr) * SEMI?
//
lbl_expr ::=
    label_longident type_constraint_stro ? EQ expr
  | label_longident type_constraint_stro ?
//
//
field_expr_list ::=
    field_expr (SEMI field_expr) * SEMI ?

field_expr ::=
    label EQ expr
  | label

expr_semi_list ::=
    expr (SEMI expr) *
//
type_constraint_stro ::=
    COLON core_type
  | COLON core_type COLON_GT core_type
  | COLON_GT core_type
//
//opt_type_constraint ::=
//    type_constraint
//  | /* empty */
//
//
///* Patterns */
//
pattern_expression ::=
    val_ident_pattern_expression
  | comma_list_pattern_expression  //%prec below_COMMA
  | coloncolon_separated_pattern_expression
  | bar_pattern_expression
  | exception_pattern_expression
  | attribute_pattern_expression
  | pattern_gen_pattern_expression

val_ident_pattern_expression ::=
    pattern_expression AS value_name

coloncolon_separated_pattern_expression ::=
    pattern_expression SHORTCUT pattern_expression

bar_pattern_expression ::=
    pattern_expression PIPE pattern_expression

pattern_gen_pattern_expression ::=
    pattern_gen

attribute_pattern_expression ::=
    pattern_expression attribute

exception_pattern_expression ::= EXCEPTION pattern_expression //%prec prec_constr_appl

comma_list_pattern_expression ::=
    pattern_expression (COMMA pattern_expression) +


pattern_no_exn ::=
    val_ident_pattern_no_exn
  | comma_list_pattern_no_exn  //%prec below_COMMA
  | coloncolon_separated_pattern_no_exn
  | bar_pattern_no_exn
  | attribute_pattern_no_exn
  | pattern_gen_pattern_no_exn

val_ident_pattern_no_exn ::=
    pattern_no_exn AS value_name

coloncolon_separated_pattern_no_exn ::=
    pattern_no_exn SHORTCUT pattern_no_exn

bar_pattern_no_exn ::=
    pattern_no_exn PIPE pattern_no_exn

pattern_gen_pattern_no_exn ::=
    pattern_gen

attribute_pattern_no_exn ::=
    pattern_no_exn attribute

comma_list_pattern_no_exn ::=
    pattern_no_exn (COMMA pattern_expression) +

pattern_gen ::=
    constr_longident pattern_expression //%prec prec_constr_appl
  | name_tag pattern_expression //%prec prec_constr_appl
  | simple_pattern
  | LPAREN SHORTCUT RPAREN LPAREN pattern_expression COMMA pattern_expression RPAREN
  | LAZY simple_pattern

simple_pattern ::=
    val_decl //%prec below_EQUAL
  | simple_pattern_not_ident

simple_pattern_not_ident ::=
  UNDERSCORE
  | signed_constant DOTDOT signed_constant
  | signed_constant
  | constr_longident
  | name_tag
  | SHARP type_longident
  | LBRACE lbl_pattern_list RBRACE
  | LBRACKET pattern_semi_list SEMI ? RBRACKET
  | LARRAY pattern_semi_list SEMI ? RARRAY
  | LARRAY RARRAY
  | LPAREN pattern_expression RPAREN
  | LPAREN pattern_expression COLON core_type RPAREN
  | LPAREN MODULE CAPITALIZED_IDENT RPAREN
  | LPAREN MODULE CAPITALIZED_IDENT COLON package_type RPAREN
  | extension

pattern_semi_list ::=
    pattern_expression (SEMI pattern_expression) *

lbl_pattern_list ::=
    lbl_pattern (SEMI lbl_pattern) * (SEMI UNDERSCORE)? SEMI?

lbl_pattern ::=
    label_longident opt_pattern_type_constraint ? EQ pattern_expression
  | label_longident opt_pattern_type_constraint ?


opt_pattern_type_constraint ::=
    COLON core_type

/* Type declarations */
generalized_constructor_arguments ::=
    OF constr_args

///* Polymorphic types */

typevar_list ::=
    (SINGLE_QUOTE ident) +

poly_type ::=
    typevar_list DOT core_type
  | core_type


poly_type_no_attr ::=
        core_type_no_attr
      | typevar_list DOT core_type_no_attr


///* Core types */
//
core_type ::=
    // [CHANGE] Add support for COLON_GT
    core_type_no_attr (attribute|COLON_GT core_type_no_attr)?

core_type_no_attr ::=
    (minusgreater_coretype2| core_type2) (AS SINGLE_QUOTE ident)?

minusgreater_coretype2 ::=
    core_type2 (RIGHT_ARROW core_type2)+

core_type2 ::=
    QUESTION_MARK LOWERCASE_IDENT COLON core_type2
  | OPTLABEL core_type2
  | LOWERCASE_IDENT COLON core_type2
  | simple_core_type_or_tuple

simple_core_type ::=
    simple_core_type2 sumple_core_type2_suffix * ////%prec below_SHARP
  | LPAREN core_type_comma_list RPAREN ////%prec below_SHARP

sumple_core_type2_suffix ::=
    SHARP class_longident
    | type_longident

simple_core_type2 ::=
    SINGLE_QUOTE ident (DOT SINGLE_QUOTE ident)?
  | UNDERSCORE
  | type_longident
  | LPAREN core_type_comma_list RPAREN type_longident
  // [CHANGES]: uncommented all
  | LT meth_list GT
  | LT GT
  | SHARP class_longident
  | LPAREN core_type_comma_list RPAREN SHARP class_longident
  | LBRACKET tag_field RBRACKET
/* PR#3835: this is not LR(1), would need lookahead=2
  | LBRACKET simple_core_type RBRACKET
*/
  | LBRACKET PIPE? row_field_list RBRACKET
  | LBRACKETGREATER row_field_list RBRACKET
  | LBRACKETLESS row_field_list RBRACKET
//  | LBRACKETGREATER PIPE ? row_field_list RBRACKET
  | LBRACKETGREATER RBRACKET
//  | LBRACKETLESS PIPE ? row_field_list RBRACKET
//  | LBRACKETLESS PIPE ? row_field_list GT name_tag_list RBRACKET
  | LPAREN MODULE package_type RPAREN
  | extension

package_type ::=
    module_type

row_field_list ::=
    row_field (PIPE row_field)*

row_field ::=
    tag_field
  | simple_core_type

tag_field ::=
    name_tag OF AMPERSAND ? amper_type_list
  | name_tag

amper_type_list ::=
    core_type_no_attr (AMPERSAND core_type_no_attr) *
//
//name_tag_list ::=
//    name_tag
//  | name_tag_list name_tag
//
simple_core_type_or_tuple ::=
    simple_core_type (STAR core_type_list) ?

core_type_comma_list ::=
    core_type (COMMA core_type) *

core_type_list ::=
    simple_core_type (STAR simple_core_type) *

meth_list ::=
    field_semi meth_list
  | field_semi
  | field
  | DOTDOT

field ::=
  label COLON poly_type_no_attr

field_semi ::=
  label COLON poly_type_no_attr SEMI

label ::=
    LOWERCASE_IDENT

///* Constants */
//
constant ::=
    INTEGER_VALUE
  | CHAR_VALUE
  | STRING_VALUE
  | FLOAT_VALUE

signed_constant ::=
    constant
  | MINUS INTEGER_VALUE
  | MINUS FLOAT_VALUE
  | PLUS INTEGER_VALUE
  | PLUS FLOAT_VALUE

/* Identifiers and long identifiers */
constr_ident ::=
    CAPITALIZED_IDENT
  | LBRACKET RBRACKET
  | LPAREN RPAREN
  /* | SHORTCUT                                */
  | LPAREN SHORTCUT RPAREN
  // [CHANGE]: add BOOL_VALUE and remove both
  | BOOL_VALUE

val_longident ::=
    value_name
  | mod_longident DOT value_name

constr_longident ::=
    mod_longident       ////%prec below_DOT
  | LBRACKET RBRACKET
  | LPAREN RPAREN
  // [CHANGE]: add BOOL_VALUE and remove both
  | BOOL_VALUE

label_longident ::=
    LOWERCASE_IDENT
  | mod_longident DOT LOWERCASE_IDENT

type_longident ::=
    LOWERCASE_IDENT
    // [CHANGE]: stop using mod_ext as we can have A.B(C).t
//  | mod_ext_longident DOT LOWERCASE_IDENT
    | CAPITALIZED_IDENT (LPAREN CAPITALIZED_IDENT (DOT CAPITALIZED_IDENT)* RPAREN)? DOT type_longident

// [CHANGE]: too few cases were handled. We need to handle:
// A
// A.B
// A.B(C)
// A.B(C.D)
// A.B(C.D(E))
module_path_stro ::=
    CAPITALIZED_IDENT (DOT CAPITALIZED_IDENT)* (LPAREN module_path_stro RPAREN)?

mod_longident ::=
    CAPITALIZED_IDENT (DOT CAPITALIZED_IDENT)*

class_longident ::=
    LOWERCASE_IDENT
  | { CAPITALIZED_IDENT (DOT CAPITALIZED_IDENT)* } DOT LOWERCASE_IDENT

/* Miscellaneous */

name_tag ::=
    BACKTICK ident

direction_flag ::=
    TO
  | DOWNTO

private subtractive ::=
  TILDE? MINUS
  | TILDE? MINUSDOT

private additive ::=
  TILDE? PLUS
  | TILDE? PLUSDOT

