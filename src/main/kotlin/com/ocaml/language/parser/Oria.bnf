{
  parserClass="com.ocaml.language.parser.OCamlParser"
  parserUtilClass="com.ocaml.language.parser.OCamlParserUtils"
  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="OCaml"
  psiImplClassSuffix="Impl"
  psiPackage="com.ocaml.language.psi"
  psiImplPackage="com.ocaml.language.psi.impl"
  psiImplUtilClass="com.ocaml.language.psi.OCamlImplUtils"

  generateTokens=true
  generateTokenAccessors=false

  elementTypeHolderClass="com.ocaml.language.psi.OCamlTypes"
  elementTypeClass="com.ocaml.language.psi.api.OCamlElementType"
  tokenTypeClass="com.ocaml.language.psi.api.OCamlTokenType"

  tokens = [
          AND = "and"
          AS = "as"
          ASSERT = "assert"
          BEGIN = "begin"
          CLASS = "class"
          CONSTRAINT = "constraint"
          DO = "do"
          DONE = "done"
          DOWNTO = "downto"
          ELSE = "else"
          END = "end"
          EXCEPTION = "exception"
          EXTERNAL = "external"
          FOR = "for"
          FUN = "fun"
          FUNCTION = "function"
          FUNCTOR = "functor"
          IF = "if"
          IN = "in"
          INCLUDE = "include"
          INHERIT = "inherit"
          INITIALIZER = "initializer"
          LAZY = "lazy"
          LET = "let"
          MODULE = "module"
          MUTABLE = "mutable"
          NEW = "new"
          NONREC = "nonrec"
          OBJECT = "object"
          OF = "of"
          OPEN = "open"
          OR = "or"
          REC = "rec"
          SIG = "sig"
          STRUCT = "struct"
          THEN = "then"
          TO = "to"
          TRY = "try"
          TYPE = "type"
          VAL = "val"
          VIRTUAL = "virtual"
          WHEN = "when"
          WHILE = "while"
          WITH = "with"
          LBRACELESS = "{<"
          GREATERRBRACE = ">}"

          MOD = "mod"
          LAND = "land"
          LOR = "lor"
          LXOR = "lxor"
          LSL = "lsl"
          LSR = "lsr"
          ASR = "asr"

          TRUE = "true"
          FALSE = "false"

          METHOD = "method"
          PRIVATE = "private"
          MATCH = "match"

          UNDERSCORE = "_"

          SHORTCUT = "::"
          RIGHT_ARROW = "->"
          LEFT_ARROW = "<-"
          LARRAY = "[|"
          RARRAY = "|]"

          EQ = "="
          NOT_EQ = "!="
          COLON_EQ = ":="
          COLON_GT = ":>"
          SEMISEMI = ";;"
          L_OR = "||"
          L_AND = "&&"

          CARRET = "^"
          MINUSDOT = "-."
          PLUSEQ = "+="
          PLUS = "+"
          MINUS = "-"
          SLASH = "/"
          STAR = "*"

          COMMA = ","
          COLON = ":"
          SEMI = ";"
          SINGLE_QUOTE = "'"
          DOTDOT = ".."
          DOT = "."
          PIPE = "|"
          LPAREN = "("
          RPAREN = ")"
          LBRACE = "{"
          RBRACE = "}"
          LBRACKET = "["
          RBRACKET = "]"
          ARROBASE = "@"
          SHARP = "#"
          QUESTION_MARK = "?"
          EXCLAMATION_MARK = "!"
          DOLLAR = "$"
          BACKTICK = "`"
          TILDE = "~"
          AMPERSAND = "&"

          PERCENT = "%"

          LT = "<"
          GT = ">"

          LBRACKETGREATER = "[>"
          LBRACKETLESS = "[<"

          COMMENT = "COMMENT"
          DOC_COMMENT = "DOC_COMMENT"
    ]

  extends(".*pattern_no_exn")=pattern_no_exn
  extends(".*pattern_expression")=pattern_expression

  extends("infix_expr|non_op_expr|expr")=expr
  extends("expr_comma_list|coloncolon_bin_expr|sign_unary_expr")=expr

  extends("first_class_module_expr|sharpop_expr|.*_object_expr|.*_with_local_open_expr")=simple_expr
  extends("bang_expr|list_constructor_expr|array_constructor_expr|.*_assign_expr|.*_lookup_expr")=simple_expr
  extends("record_constructor_expr|sharp_op_expr|non_op_simple_expr|simple_expr")=simple_expr
}

// ALL MAJOR TODOS
// todo:  aliases are not handled

/*
Copyright (c) 1996 Institut National de Recherche en Informatique et en Automatique.
Copyright (c) 2021 Sidharth Kuruvila
Source: https://github.com/ocaml/ocaml/blob/4.14/parsing/parser.mly
Reference: https://v2.ocaml.org/manual/lex.html
*/
/* Entry points */
file ::= COMMENT
| DOC_COMMENT
| ANNOTATION
//| unit-interface
| unit-implementation

// INTERNAL TOKENS THAT WERE NOT IN THE  DOCUMENTATION
// otherwise lowercase and capitalized are not recognized as ident
ident ::= CAPITALIZED_IDENT | LOWERCASE_IDENT

private infix_symbol_lexed ::= // PIPE is rejected, but all these are lexed alone
 DOLLAR | AMPERSAND | STAR | PLUS | MINUS | SLASH | EQ | GT | ARROBASE | CARRET
 // and all of them are lexed too (:> -> <- [< and [> are lexed but not valid)
 | NOT_EQ | COLON_EQ | L_OR | L_AND | MINUSDOT | PLUSEQ
 // These two are valid and lexed alone
 | LT | PERCENT
 // And this one is valid but dunno from which rule as it's not in CORE_OPERATOR_CHAR
 | EXCLAMATION_MARK

// https://v2.ocaml.org/releases/4.14/htmlman/compunit.html#start-section
unit-implementation ::= [ module-items ]
//unit-interface ::=  { specification [SEMISEMI] }+

// https://v2.ocaml.org/releases/4.14/htmlman/lex.html#sss:integer-literals
integer_literal ::= [MINUS] INTEGER_VALUE
int32_literal ::=  integer_literal "l"
int64_literal ::=  integer_literal "L"
nativeint_literal ::=  integer_literal "n"

// https://v2.ocaml.org/releases/4.14/htmlman/lex.html#sss:floating-point-literals
float_literal ::= [MINUS] FLOAT_VALUE

// https://v2.ocaml.org/releases/4.14/htmlman/lex.html#sss:character-literals
char_literal ::= CHAR_VALUE

// https://v2.ocaml.org/releases/4.14/htmlman/lex.html#sss:stringliterals
string_literal ::= STRING_VALUE

// https://v2.ocaml.org/releases/4.14/htmlman/lex.html#sss:labelname
label_name ::= LOWERCASE_IDENT
// these two were unused, dunno why
// label ::=  TILDE label_name COLON
// optlabel ::=  QUESTION_MARK label_name COLON

// https://v2.ocaml.org/releases/4.14/htmlman/lex.html#sss:lex-ops-symbols
infix_symbol ::= INFIX_SYMBOL_VALUE | infix_symbol_lexed
prefix_symbol ::= PREFIX_SYMBOL_VALUE

//linenum-directive ::= SHARP { DIGIT }+ '"' { string-character } '"'

// https://v2.ocaml.org/releases/4.14/htmlman/names.html#sss:naming-objects
// [CHANGES]: raise can be used as an identifier (value_name)
value_name ::= LOWERCASE_IDENT
  | LPAREN operator_name RPAREN

operator_name ::= prefix_symbol | infix_op

infix_op ::= infix_symbol
  |  STAR | PLUS | MINUS | MINUSDOT | EQ | NOT_EQ | LT | GT | OR | L_OR | AMPERSAND | L_AND | COLON_EQ
  |  MOD | LAND | LOR | LXOR | LSL | LSR | ASR

constr_name ::= CAPITALIZED_IDENT

tag_name ::= CAPITALIZED_IDENT

typeconstr_name ::= LOWERCASE_IDENT

field_name ::= LOWERCASE_IDENT

// [BACK]: was UIDENT | UNDERSCORE
module_name ::= CAPITALIZED_IDENT

modtype_name ::= ident

class_name ::= LOWERCASE_IDENT

inst_var_name ::= LOWERCASE_IDENT

method_name ::= LOWERCASE_IDENT

// https://v2.ocaml.org/releases/4.14/htmlman/names.html#sss:refer-named
value_path ::= [ module_path DOT ] value_name

constr ::= [ module_path DOT ] constr_name

typeconstr ::= [ extended_module_path DOT ] typeconstr_name

field ::= [ module_path DOT ] field_name

// [BACK]: was ident (DOT ident) *
modtype_path ::= [ extended_module_path DOT ] modtype_name

classtype_path ::= [ extended_module_path DOT ] class_name

module_path ::= module_name { DOT module_name }*

extended_module_path ::= extended_module_name { DOT extended_module_name }*

extended_module_name ::= module_name { LPAREN extended_module_path RPAREN }*

// https://v2.ocaml.org/releases/4.14/htmlman/types.html#s:typexpr
// todo: major element not OK
typexpr ::= typexpr_no_attr
// 4.b. handle RIGHT_ARROW with no label
// 7. handle as SINGLE_QUOTE ident
private typexpr_no_attr ::=
    { typexpr2 { RIGHT_ARROW typexpr2 }+ | typexpr2 } [AS SINGLE_QUOTE ident]

// 4.a. handle RIGHT_ARROW with label
// [BETS]: Removed: "| OPTLABEL typexpr2" and "| LOWERCASE_IDENT COLON typexpr2"
private typexpr2 ::=
    [QUESTION_MARK] label_name COLON typexpr2
  | simple_typeexpr_or_tuple

// 5. Handle tuples
private simple_typeexpr_or_tuple ::=
    simple_typeexpr [ STAR simple_typeexpr { STAR simple_typeexpr }* ]

// Not sure which one is handled here
private simple_typeexpr ::=
    simple_typeexpr2 { simple_typeexpr2_suffix } *
  | LPAREN typexpr { COMMA typexpr }* RPAREN

private simple_typeexpr2_suffix ::=
    SHARP class_longident
    | type_longident

private simple_typeexpr2 ::=
    SINGLE_QUOTE ident (DOT SINGLE_QUOTE ident)?
  | UNDERSCORE
  | type_longident
  | LPAREN typexpr { COMMA typexpr }* RPAREN type_longident
  // [CHANGES]: uncommented all
  | LT meth_list GT
  | LT GT
  | SHARP class_longident
  | LPAREN typexpr { COMMA typexpr }* RPAREN SHARP class_longident
  | LBRACKET tag_field RBRACKET
/* PR#3835: this is not LR(1), would need lookahead=2
  | LBRACKET simple_core_type RBRACKET
*/
  | LBRACKET PIPE? row_field_list RBRACKET
  | LBRACKETGREATER row_field_list RBRACKET
  | LBRACKETLESS row_field_list RBRACKET
//  | LBRACKETGREATER PIPE ? row_field_list RBRACKET
  | LBRACKETGREATER RBRACKET
//  | LBRACKETLESS PIPE ? row_field_list RBRACKET
//  | LBRACKETLESS PIPE ? row_field_list GT name_tag_list RBRACKET
  | LPAREN MODULE package_type RPAREN

poly_typexpr ::=
    { SINGLE_QUOTE ident }+ DOT typexpr
  | typexpr

// https://v2.ocaml.org/releases/4.14/htmlman/types.html#sss:typexpr-polyvar

// https://v2.ocaml.org/releases/4.14/htmlman/const.html#s:const
constant ::= integer_literal
 |  int32_literal
 |  int64_literal
 |  nativeint_literal
 |  float_literal
 |  char_literal
 |  string_literal
 |  constr
 |  FALSE
 |  TRUE
 |  LPAREN RPAREN
 |  BEGIN END
 |  LBRACKET RBRACKET
 |  LARRAY RARRAY
 |  BACKTICK tag_name

// https://v2.ocaml.org/releases/4.14/htmlman/patterns.html#s:patterns

// https://v2.ocaml.org/releases/4.14/htmlman/expr.html#s:value-expr
private seq_expr ::= expr { SEMI expr } *  [SEMI] // [ expr { ; expr } [;] ]

// [BETS]: removed coloncolon_app_rule
// expr ::=
//  |  [| expr { ; expr } [;] |]
//  |  { field [: typexpr] [= expr]{ ; field [: typexpr] [= expr] } [;] }
//  |  { expr with field [: typexpr] [= expr]{ ; field [: typexpr] [= expr] } [;] }
//  |  expr { argument }+
//  |  expr . field
//  |  expr . field <- expr
//  |  expr .( expr )
//  |  expr .( expr ) <- expr
//  |  expr .[ expr ]
//  |  expr .[ expr ] <- expr
//  |  expr ; expr
//  |  ( expr :> typexpr )
//  |  ( expr : typexpr :> typexpr )
//  |  local-open
expr ::=
    expr_comma_list
  | non_op_expr
  | coloncolon_bin_expr
  | infix_expr
  | sign_unary_expr

expr_comma_list ::= expr { COMMA expr } +                               // expr { , expr } +
coloncolon_bin_expr ::= expr SHORTCUT expr { rightAssociative = true }  // expr :: expr
infix_expr ::= expr infix_op expr                                       // expr infix-op expr
sign_unary_expr ::= (MINUS|MINUSDOT|prefix_symbol) expr   // "- expr", "-. expr" "prefix-symbol expr"

// todo: add here "LET OPEN [EXCLAMATION_MARK] module_path_stro IN seq_expr"
// todo: pattern_matching, labeled_simple_pattern
// [BETS]: removed "FUN LPAREN TYPE lident_list RPAREN fun_def"
// [BETS]: removed "FOR pattern_expression"
non_op_expr ::=
    LET [REC] let_binding { AND let_binding } * IN seq_expr             // let [rec] let-binding { and let-binding } in expr
  | LET MODULE module_name { LPAREN module_name COLON module_type RPAREN }* [COLON module_type] IN seq_expr // let module module-name { ( module-name : module-type ) } [ : module-type ]  = module-expr in expr
  | LET EXCEPTION constr_decl IN seq_expr                               // let exception constr-decl in expr
  | FUNCTION pattern_matching                                           // function pattern-matching
  | FUN { labeled_simple_pattern } * [ COLON simple_typeexpr ] RIGHT_ARROW seq_expr // fun { parameter }+ [ : typexpr ] -> expr
  | MATCH seq_expr WITH pattern_matching                                // match expr with pattern-matching
  | TRY seq_expr WITH pattern_matching                                  // try expr with pattern-matching
  | constr simple_expr                                                  // constr expr
  | BACKTICK tag_name simple_expr                                       // `tag-name expr
  | IF expr THEN expr [ELSE expr]                                       // if expr then expr [ else expr ]
  | WHILE seq_expr DO seq_expr DONE                                     // while expr do expr done
  | FOR value_name EQ seq_expr (TO | DOWNTO) seq_expr DO seq_expr DONE  // for value-name = expr ( to | downto ) expr do expr done
  | ASSERT simple_expr                                                  // assert expr
  | LAZY simple_expr                                                    // lazy expr
  | object_expr
  | simple_expr labeled_simple_expr *
  | simple_expr

// [BETS]: remove local_open_group???
simple_expr ::=
//    local_open_group
  non_op_simple_expr
  | record_constructor_expr
  | assign_expr
  | lookup_expr
  | array_constructor_expr
  | list_constructor_expr
  | bang_expr
  | new_object_expr
  | self_copy_object_expr
  | send_message_object_expr
  | sharpop_expr
  | first_class_module_expr

//private local_open_group ::=
//      object_copy_with_local_open_expr
//    | expr_with_local_open_expr
//    | list_constructor_with_local_open_expr
//    | array_constructor_with_local_open_expr
//    | record_constructor_with_local_open_expr
//    | first_class_module_with_local_open_expr
//
//object_copy_with_local_open_expr ::= mod_longident DOT LBRACELESS field_expr_list ? GREATERRBRACE
//expr_with_local_open_expr ::= mod_longident DOT LPAREN seq_expr RPAREN
//list_constructor_with_local_open_expr ::= mod_longident DOT LBRACKET expr_semi_list SEMI ? RBRACKET
//array_constructor_with_local_open_expr ::= mod_longident DOT LARRAY ( expr_semi_list SEMI ? )? RARRAY
//record_constructor_with_local_open_expr ::= mod_longident DOT LBRACE record_expr RBRACE
//first_class_module_with_local_open_expr ::= mod_longident DOT LPAREN MODULE module_expr COLON package_type RPAREN

// fixme: actually, we can have "A.B expr" not just "A.b expr" (value-path)
// [BETS]: removed constr_longident
non_op_simple_expr ::= value_path                  // value-path
  | constant                                       // constant
  | constr                                         // **** duplicate
  | BACKTICK ident                                 // **** duplicate
  | LPAREN seq_expr RPAREN                         // ( expr )
  | BEGIN [seq_expr] END                           // begin expr end
  | LPAREN seq_expr COLON typexpr RPAREN           // ( expr : typexpr )

// todo: not done and not correct
object_expr ::= inst_var_name LESSMINUS expr
| OBJECT class_structure ? END

// https://v2.ocaml.org/releases/4.14/htmlman/typedecl.html#ss:typedefs
type_definition ::= TYPE [NONREC] typedef { AND typedef }*

// [BETS]: used type_params instead of optional_type_parameters
typedef ::= [type_params] typeconstr_name type_information

type_information ::= [type_equation] [type_representation] { type_constraint }*

// [BETS]: removed a bunch of stuff with private opt
type_equation ::= EQ typexpr
| private_type_equation

type_representation ::=
    EQ [PIPE] constr_decl { PIPE constr_decl } *
  | EQ record_decl
  | EQ PIPE
  | private_type_representation
  | type_extension_representation

type_params ::= type_param
  |  LPAREN type_param { COMMA type_param }* RPAREN

type_param ::= [ext_variance] SINGLE_QUOTE ident
//optional_type_param ::= [ext_variance] (SINGLE_QUOTE ident|UNDERSCORE)

ext_variance ::= variance [injectivity]
  |  injectivity [variance]

variance ::= PLUS | MINUS

injectivity ::= EXCLAMATION_MARK

record_decl ::= LBRACE field_decl { SEMI field_decl }* [SEMI] RBRACE

// fixme: constr_decl doesn't support ":" (see: https://v2.ocaml.org/releases/4.14/htmlman/gadts.html#s:gadts)
// [BEST]: removed from first LPAREN RPAREN (unit) and true|false
// [BEST]: removed "| COLON constr_args RIGHT_ARROW simple_core_type"
// [BEST]: removed "| COLON simple_core_type"
constr_decl ::= (constr_name | LBRACKET RBRACKET | LPAREN SHORTCUT RPAREN) [OF constr_args]

// [MAJOR]: used simple_typeexpr
constr_args ::= simple_typeexpr { STAR simple_typeexpr } *
| inline_records_constr_args

field_decl ::= [MUTABLE] field_name COLON poly_type_no_attr // todo

type_constraint ::= CONSTRAINT typexpr EQ typexpr

// https://v2.ocaml.org/releases/4.14/htmlman/typedecl.html#ss:exndef
exception_definition ::= EXCEPTION constr_name EQ constr
| exception_specification

exception_specification ::= EXCEPTION constr_decl

// https://v2.ocaml.org/releases/4.14/htmlman/classes.html#ss:classes:class-types
// [MAJOR]: using simple_core_type_or_tuple
// [BETS]: using RAW opt label
// [OPT]: go back to two lines?
class_type ::=
    QUESTION_MARK LOWERCASE_IDENT COLON simple_typeexpr_or_tuple RIGHT_ARROW class_type
  | LOWERCASE_IDENT COLON simple_typeexpr_or_tuple RIGHT_ARROW class_type
  | simple_typeexpr_or_tuple RIGHT_ARROW class_type
  | class_body_type

class_body_type ::=
      OBJECT [LPAREN typexpr RPAREN] { class_field_spec } * END
    | LBRACKET typexpr { COMMA typexpr } * RBRACKET classtype_path
    | LET OPEN module_path IN class_body_type

class_field_spec ::=
    INHERIT class_body_type
  | VAL [MUTABLE] [VIRTUAL] inst_var_name COLON typexpr
  | VAL VIRTUAL MUTABLE inst_var_name COLON typexpr
  | METHOD [PRIVATE] [VIRTUAL] method_name COLON poly_typexpr
  | METHOD VIRTUAL PRIVATE method_name COLON poly_typexpr
  | CONSTRAINT typexpr EQ typexpr

// https://v2.ocaml.org/releases/4.14/htmlman/classes.html#ss:class-expr
// todo
class_expr ::=
    class_simple_expr { simple_expr | label_expr } *
  | class_simple_expr
  | FUN class_fun_def
  | let_bindings IN class_expr

private class_simple_expr ::=
    LBRACKET typexpr { COMMA typexpr } * RBRACKET class_longident
  | class_longident
  | OBJECT class_structure ? END
  | LPAREN class_expr COLON class_type RPAREN
  | LPAREN class_expr RPAREN

// todo: seq_expr
class_field ::=
    INHERIT class_expr [AS LOWERCASE_IDENT]
  | INHERIT [EXCLAMATION_MARK] class_expr [AS LOWERCASE_IDENT]
  | VAL [MUTABLE] inst_var_name [COLON typexpr] EQ seq_expr
  | VAL [EXCLAMATION_MARK] [MUTABLE] inst_var_name [COLON typexpr] EQ seq_expr
  | VAL [MUTABLE] VIRTUAL inst_var_name COLON typexpr
  | VAL VIRTUAL MUTABLE inst_var_name COLON typexpr
  | METHOD [PRIVATE] method_name class_field_strict_binding
  | METHOD EXCLAMATION_MARK [PRIVATE] method_name class_field_strict_binding
  | METHOD [PRIVATE] method_name COLON poly_typexpr EQ seq_expr
  | METHOD EXCLAMATION_MARK [PRIVATE] method_name COLON poly_typexpr EQ seq_expr
  | METHOD [PRIVATE] VIRTUAL method_name COLON poly_typexpr
  | METHOD VIRTUAL PRIVATE method_name COLON poly_typexpr
  | CONSTRAINT typexpr EQ typexpr
  | INITIALIZER seq_expr

// [BETS]: unsure if this pattern is the correct one
private class_field_strict_binding ::=
    { labeled_simple_pattern } * [COLON typexpr] EQ seq_expr

// https://v2.ocaml.org/releases/4.14/htmlman/classes.html#sss:class-body

// https://v2.ocaml.org/releases/4.14/htmlman/classes.html#ss:class-def
class_definition ::= CLASS class_binding { AND class_binding } *

class_binding ::=
    [VIRTUAL] [class_type_parameters] class_name { labeled_simple_pattern }* // todo
    [COLON class_type] EQ class_expr

private class_type_parameters ::= LBRACKET type_parameters RBRACKET
type_parameters ::= SINGLE_QUOTE ident { COMMA SINGLE_QUOTE ident }*

// https://v2.ocaml.org/releases/4.14/htmlman/classes.html#ss:class-spec
class_specification ::= CLASS class_spec { AND class_spec } *
class_spec ::= [VIRTUAL] [class_type_parameters] class_name COLON class_type

// https://v2.ocaml.org/releases/4.14/htmlman/classes.html#ss:classtype
classtype_definition ::= CLASS TYPE classtype_def { AND classtype_def } *
classtype_def ::= [VIRTUAL] [class_type_parameters] class_name EQ class_body_type

// https://v2.ocaml.org/releases/4.14/htmlman/modtypes.html#s:modtypes
private base_module_type ::= modtype_path
  | SIG [SEMISEMI] { specification [SEMISEMI] }* END // added [SEMISEMI]
  | FUNCTOR LPAREN module_name COLON module_type RPAREN RIGHT_ARROW module_type
  | LPAREN module_type RPAREN
  | module_type_typeof

private module_type_suffix ::=
    RIGHT_ARROW module_type
    | WITH mod_constraint { AND mod_constraint }*

module_type ::= base_module_type [module_type_suffix]

// [BETS]: replaced previous names/paths with others
mod_constraint ::=
    TYPE [type_params] typeconstr type_equation { type_constraint }*
  | MODULE module_path EQ extended_module_path
  | signature_substitution_mod_constraint

// [BETS]: removed module_alias ::= MODULE (CAPITALIZED_IDENT|UNDERSCORE) EQ mod_longident
specification ::=
    value_description
  | type_definition
  | exception_specification
  | class_specification
  | classtype_definition
  | module_declaration
  | module_type_declaration
  | open_statement
  | sig_include_statement
  // extensions
  | type_extension_definition
  | recursive_module_extension_spec
  | module_alias_spec
  | signature_substitution_spec
  // special
  | primitive_declaration

private value_description ::= VAL value_name COLON typexpr

private module_declaration ::=
    MODULE module_name COLON module_type
  | MODULE module_name LPAREN module_name COLON module_type RPAREN COLON module_type

private module_type_declaration ::=
    MODULE TYPE modtype_name
    | MODULE TYPE modtype_name EQ module_type

private open_statement ::= OPEN module_path

private sig_include_statement ::= INCLUDE module_type

// https://v2.ocaml.org/releases/4.14/htmlman/modules.html#s:module-expr
module-items ::= // todo: seq_expr and fixme: definition|specification
{ SEMISEMI }* (definition|specification|seq_expr)? { { SEMISEMI }* ( definition | specification | SEMISEMI seq_expr) }* { SEMISEMI }*

// todo
definition ::=
    let_bindings
  | type_definition
  | exception_definition
  | module_binding
  | module_type_declaration
  | open_statement
  | class_definition
  | classtype_definition
  | str_include_statement
  // extensions
  | type_extension_specification
  | recursive_module_extension_def
  // special
  | primitive_declaration

// https://v2.ocaml.org/releases/4.14/htmlman/intfc.html#s:c-overview
primitive_declaration ::=
    EXTERNAL value_name COLON typexpr EQ external_declaration

external_declaration ::= STRING_VALUE [ STRING_VALUE [ STRING_VALUE ] ]

// https://v2.ocaml.org/releases/4.14/htmlman/recursivemodules.html#s:recursive-modules
// [BETS]: discard rec_module_bindings ; rec_module_binding ; and_module_binding
private recursive_module_extension_def ::=
    MODULE REC module_name COLON module_type EQ module_expr
    { AND module_name COLON module_type EQ module_expr } *

private recursive_module_extension_spec ::=
    MODULE REC module_name COLON module_type { AND module_name COLON module_type } *

// https://v2.ocaml.org/releases/4.14/htmlman/generalizedopens.html#s:generalized-open

// https://v2.ocaml.org/releases/4.14/htmlman/extensiblevariants.html
private type_extension_representation ::= EQ DOTDOT
| PRIVATE EQ DOTDOT

// [BETS]: removed [NONREC]
// [BETS]: removed optional_type_parameters
// [BETS]: removed type_longident and used typeconstr
private type_extension_specification ::= TYPE [type_params] typeconstr type_extension_spec
private type_extension_definition ::= TYPE [type_params] typeconstr type_extension_def

type_extension_spec ::= PLUSEQ [PRIVATE] [PIPE] constr_decl { PIPE constr_decl } *
type_extension_def ::= PLUSEQ [PRIVATE] [PIPE] constr_def { PIPE constr_def } *

// [BETS]: used 'constr_name' instead of '... | () | [] | true | false'
// [BETS]: used 'constr' instead of '... | () | [] | true | false'
constr_def ::= constr_decl | constr_name EQ constr

// https://v2.ocaml.org/releases/4.14/htmlman/moduletypeof.html#s:module-type-of
private module_type_typeof ::= MODULE TYPE OF module_expr

// (3/3) https://v2.ocaml.org/releases/4.14/htmlman/privatetypes.html#s:private-types
private private_type_equation ::= EQ PRIVATE typexpr

private private_type_representation ::=
    EQ PRIVATE [PIPE] constr_decl { PIPE constr_decl } *
  | EQ PRIVATE record_decl
  | EQ PRIVATE PIPE

// (1/1) https://v2.ocaml.org/releases/4.14/htmlman/modulealias.html#s:module-alias
private module_alias_spec ::= MODULE module_name EQ module_path

// (1/1) https://v2.ocaml.org/releases/4.14/htmlman/signaturesubstitution.html#s:signature-substitution
private signature_substitution_mod_constraint ::=
    TYPE [type_params] typeconstr_name COLON_EQ typexpr
    | MODULE module_path COLON_EQ extended_module_path
    | MODULE TYPE modtype_path EQ module_type
    | MODULE TYPE modtype_path COLON_EQ module_type

private signature_substitution_spec ::=
    TYPE type_subst { AND type_subst }*
    | MODULE module_name COLON_EQ extended_module_path
    | MODULE TYPE module_name COLON_EQ module_type

type_subst ::= [type_params] typeconstr_name COLON_EQ typexpr { type_constraint }*

// (1/1) https://v2.ocaml.org/releases/4.14/htmlman/inlinerecords.html#s:inline-records
private inline_records_constr_args ::= record_decl






// [CHANGE]: added all 4 below
BOOL_VALUE ::= TRUE | FALSE

functor_arg ::=
    LPAREN RPAREN
  | LPAREN functor_arg_name COLON module_type RPAREN

functor_arg_name ::=
    CAPITALIZED_IDENT
  | UNDERSCORE

functor_args ::=
    functor_arg +

module_expr_sufix ::=
    (LPAREN module_expr RPAREN | LPAREN RPAREN | module_expr attribute) +

module_expr ::=
    mod_longident module_expr_sufix?
  | STRUCT module-items END module_expr_sufix?
  | FUNCTOR functor_args RIGHT_ARROW module_expr module_expr_sufix?
  | LPAREN module_expr COLON module_type RPAREN
  | LPAREN module_expr RPAREN
  | LPAREN VAL expr RPAREN
  | LPAREN VAL expr COLON package_type RPAREN
  | LPAREN VAL expr COLON package_type COLON_GT package_type
    RPAREN
  | LPAREN VAL expr COLON_GT package_type RPAREN
  | extension

str_include_statement ::=
    INCLUDE module_expr

// [CHANGES]: using (EQ module_expr)?
module_binding_body ::=
    EQ module_expr
  | COLON module_type (EQ module_expr)?
  | functor_arg module_binding_body

module_binding ::=
    MODULE (CAPITALIZED_IDENT|UNDERSCORE) module_binding_body
///* Class expressions */

class_fun_def ::=
    labeled_simple_pattern + RIGHT_ARROW class_expr

//
class_structure ::=
   class_self_pattern ? class_fields ?
//
//
class_self_pattern ::=
    LPAREN pattern_expression RPAREN
  | LPAREN pattern_expression COLON core_type RPAREN


class_fields ::=
    class_field +

///* Core expressions */
labeled_simple_pattern ::=
    QUESTION_MARK LPAREN label_let_pattern opt_default ? RPAREN
  | QUESTION_MARK label_var
  | OPTLABEL LPAREN let_pattern opt_default ? RPAREN
  | OPTLABEL pattern_var
  | TILDE LPAREN label_let_pattern RPAREN
  | TILDE label_var
  | LABEL_OP simple_pattern
  | simple_pattern

pattern_var ::=
    LOWERCASE_IDENT
  | UNDERSCORE

opt_default ::=
    EQ seq_expr

label_let_pattern ::=
    label_var (COLON core_type)?

label_var ::=
    LOWERCASE_IDENT

let_pattern ::=
    pattern_expression (COLON core_type) ?

first_class_module_expr ::=
    LPAREN MODULE module_expr (COLON package_type) ? RPAREN

private lookup_expr ::=
    field_lookup_expr
  | array_lookup_expr
  | string_lookup_expr
  | bigarray_lookup_expr


private assign_expr ::=
    field_assign_expr
  | array_assign_expr
  | string_assign_expr
  | bigarray_assign_expr

bang_expr ::=
    EXCLAMATION_MARK simple_expr

new_object_expr ::=
    NEW class_longident

self_copy_object_expr ::=
    LBRACELESS field_expr_list ? GREATERRBRACE

send_message_object_expr ::=
    simple_expr SHARP label

array_constructor_expr ::=
  LARRAY (expr_semi_list SEMI ?) ? RARRAY

list_constructor_expr ::=
    LBRACKET expr_semi_list SEMI ? RBRACKET

field_lookup_expr ::=
    simple_expr DOT label_longident

field_assign_expr ::=
    simple_expr DOT label_longident assignment

array_lookup_expr ::=
    simple_expr DOT LPAREN seq_expr RPAREN

array_assign_expr ::=
    simple_expr DOT LPAREN seq_expr RPAREN assignment


string_lookup_expr ::=
  simple_expr DOT LBRACKET seq_expr RBRACKET

string_assign_expr ::=
    simple_expr DOT LBRACKET seq_expr RBRACKET assignment

bigarray_lookup_expr ::=
  simple_expr DOT LBRACE expr RBRACE

bigarray_assign_expr ::=
    simple_expr DOT LBRACE expr RBRACE assignment

assignment ::=
    LESSMINUS expr

record_constructor_expr ::=
    LBRACE record_expr RBRACE


sharpop_expr ::= simple_expr SHARPOP simple_expr

labeled_simple_expr ::=
    simple_expr | label_expr


label_expr ::=
    LABEL_OP simple_expr //%prec below_SHARP
  | TILDE label_ident
  | QUESTION_MARK label_ident
  | OPTLABEL simple_expr //%prec below_SHARP

label_ident ::=
    LOWERCASE_IDENT

lident_list ::=
    LOWERCASE_IDENT +

val_decl ::= value_name

// [CHANGES]: added let_binding_expr
let_binding_body_expr ::= seq_expr

private internal_let_binding_body ::=
    val_decl fun_binding
  | value_name COLON typevar_list DOT core_type EQ let_binding_body_expr
  | value_name COLON TYPE lident_list DOT core_type EQ let_binding_body_expr
  | pattern_no_exn EQ let_binding_body_expr
  | simple_pattern_not_ident COLON core_type EQ let_binding_body_expr

let_binding ::= internal_let_binding_body

let_bindings ::= LET [REC] let_binding { AND let_binding } *


//
fun_binding ::=
    strict_binding
  | type_constraint_stro EQ let_binding_body_expr

strict_binding ::=
    EQ let_binding_body_expr
  | labeled_simple_pattern fun_binding
  | LPAREN TYPE lident_list RPAREN fun_binding

pattern_matching ::=
    [PIPE] match_case (PIPE match_case) *

match_case ::=
    pattern_expression RIGHT_ARROW seq_expr
  | pattern_expression WHEN seq_expr RIGHT_ARROW seq_expr
  | pattern_expression RIGHT_ARROW DOT

record_expr ::=
    simple_expr WITH lbl_expr_list
  | lbl_expr_list
//
lbl_expr_list ::=
    lbl_expr (SEMI lbl_expr) * SEMI?
//
lbl_expr ::=
    label_longident type_constraint_stro ? EQ expr
  | label_longident type_constraint_stro ?
//
//
field_expr_list ::=
    field_expr (SEMI field_expr) * SEMI ?

field_expr ::=
    label EQ expr
  | label

expr_semi_list ::=
    expr (SEMI expr) *
//
type_constraint_stro ::=
    COLON core_type
  | COLON core_type COLON_GT core_type
  | COLON_GT core_type
//
//opt_type_constraint ::=
//    type_constraint
//  | /* empty */
//
//
///* Patterns */
//
pattern_expression ::=
    val_ident_pattern_expression
  | comma_list_pattern_expression  //%prec below_COMMA
  | coloncolon_separated_pattern_expression
  | bar_pattern_expression
  | exception_pattern_expression
  | attribute_pattern_expression
  | pattern_gen_pattern_expression

val_ident_pattern_expression ::=
    pattern_expression AS value_name

coloncolon_separated_pattern_expression ::=
    pattern_expression SHORTCUT pattern_expression

bar_pattern_expression ::=
    pattern_expression PIPE pattern_expression

pattern_gen_pattern_expression ::=
    pattern_gen

attribute_pattern_expression ::=
    pattern_expression attribute

exception_pattern_expression ::= EXCEPTION pattern_expression //%prec prec_constr_appl

comma_list_pattern_expression ::=
    pattern_expression (COMMA pattern_expression) +


pattern_no_exn ::=
    val_ident_pattern_no_exn
  | comma_list_pattern_no_exn  //%prec below_COMMA
  | coloncolon_separated_pattern_no_exn
  | bar_pattern_no_exn
  | attribute_pattern_no_exn
  | pattern_gen_pattern_no_exn

val_ident_pattern_no_exn ::=
    pattern_no_exn AS value_name

coloncolon_separated_pattern_no_exn ::=
    pattern_no_exn SHORTCUT pattern_no_exn

bar_pattern_no_exn ::=
    pattern_no_exn PIPE pattern_no_exn

pattern_gen_pattern_no_exn ::=
    pattern_gen

attribute_pattern_no_exn ::=
    pattern_no_exn attribute

comma_list_pattern_no_exn ::=
    pattern_no_exn (COMMA pattern_expression) +

pattern_gen ::=
    constr_longident pattern_expression //%prec prec_constr_appl
  | name_tag pattern_expression //%prec prec_constr_appl
  | simple_pattern
  | LPAREN SHORTCUT RPAREN LPAREN pattern_expression COMMA pattern_expression RPAREN
  | LAZY simple_pattern

simple_pattern ::=
    val_decl //%prec below_EQUAL
  | simple_pattern_not_ident

simple_pattern_not_ident ::=
  UNDERSCORE
  | signed_constant DOTDOT signed_constant
  | signed_constant
  | constr_longident
  | name_tag
  | SHARP type_longident
  | LBRACE lbl_pattern_list RBRACE
  | LBRACKET pattern_semi_list SEMI ? RBRACKET
  | LARRAY pattern_semi_list SEMI ? RARRAY
  | LARRAY RARRAY
  | LPAREN pattern_expression RPAREN
  | LPAREN pattern_expression COLON core_type RPAREN
  | LPAREN MODULE CAPITALIZED_IDENT RPAREN
  | LPAREN MODULE CAPITALIZED_IDENT COLON package_type RPAREN
  | extension

pattern_semi_list ::=
    pattern_expression (SEMI pattern_expression) *

lbl_pattern_list ::=
    lbl_pattern (SEMI lbl_pattern) * (SEMI UNDERSCORE)? SEMI?

lbl_pattern ::=
    label_longident opt_pattern_type_constraint ? EQ pattern_expression
  | label_longident opt_pattern_type_constraint ?


opt_pattern_type_constraint ::=
    COLON core_type

///* Polymorphic types */

typevar_list ::=
    (SINGLE_QUOTE ident) +

poly_type_no_attr ::=
        core_type_no_attr
      | typevar_list DOT core_type_no_attr


///* Core types */
//
core_type ::=
    // [CHANGE] Add support for COLON_GT
    core_type_no_attr (attribute|COLON_GT core_type_no_attr)?

core_type_no_attr ::=
    (minusgreater_coretype2| core_type2) (AS SINGLE_QUOTE ident)?

minusgreater_coretype2 ::=
    core_type2 (RIGHT_ARROW core_type2)+

core_type2 ::=
    QUESTION_MARK LOWERCASE_IDENT COLON core_type2
  | OPTLABEL core_type2
  | LOWERCASE_IDENT COLON core_type2
  | simple_core_type_or_tuple

simple_core_type ::=
    simple_core_type2 sumple_core_type2_suffix * ////%prec below_SHARP
  | LPAREN core_type_comma_list RPAREN ////%prec below_SHARP

sumple_core_type2_suffix ::=
    SHARP class_longident
    | type_longident

simple_core_type2 ::=
    SINGLE_QUOTE ident (DOT SINGLE_QUOTE ident)?
  | UNDERSCORE
  | type_longident
  | LPAREN core_type_comma_list RPAREN type_longident
  // [CHANGES]: uncommented all
  | LT meth_list GT
  | LT GT
  | SHARP class_longident
  | LPAREN core_type_comma_list RPAREN SHARP class_longident
  | LBRACKET tag_field RBRACKET
/* PR#3835: this is not LR(1), would need lookahead=2
  | LBRACKET simple_core_type RBRACKET
*/
  | LBRACKET PIPE? row_field_list RBRACKET
  | LBRACKETGREATER row_field_list RBRACKET
  | LBRACKETLESS row_field_list RBRACKET
//  | LBRACKETGREATER PIPE ? row_field_list RBRACKET
  | LBRACKETGREATER RBRACKET
//  | LBRACKETLESS PIPE ? row_field_list RBRACKET
//  | LBRACKETLESS PIPE ? row_field_list GT name_tag_list RBRACKET
  | LPAREN MODULE package_type RPAREN
  | extension

package_type ::=
    module_type

row_field_list ::=
    row_field (PIPE row_field)*

row_field ::=
    tag_field
  | simple_core_type

tag_field ::=
    name_tag OF AMPERSAND ? amper_type_list
  | name_tag

amper_type_list ::=
    core_type_no_attr (AMPERSAND core_type_no_attr) *
//
//name_tag_list ::=
//    name_tag
//  | name_tag_list name_tag
//
simple_core_type_or_tuple ::=
    simple_core_type (STAR core_type_list) ?

core_type_comma_list ::=
    core_type (COMMA core_type) *

core_type_list ::=
    simple_core_type (STAR simple_core_type) *

meth_list ::=
    field_semi meth_list
  | field_semi
  | field_stro
  | DOTDOT

field_stro ::=
  label COLON poly_type_no_attr

field_semi ::=
  label COLON poly_type_no_attr SEMI

label ::=
    LOWERCASE_IDENT

///* Constants */
//
constant_stro ::=
    INTEGER_VALUE
  | CHAR_VALUE
  | STRING_VALUE
  | FLOAT_VALUE

signed_constant ::=
    constant_stro
  | MINUS INTEGER_VALUE
  | MINUS FLOAT_VALUE
  | PLUS INTEGER_VALUE
  | PLUS FLOAT_VALUE

constr_longident ::=
    mod_longident       ////%prec below_DOT
  | LBRACKET RBRACKET
  | LPAREN RPAREN
  // [CHANGE]: add BOOL_VALUE and remove both
  | BOOL_VALUE

label_longident ::=
    LOWERCASE_IDENT
  | mod_longident DOT LOWERCASE_IDENT

type_longident ::=
    LOWERCASE_IDENT
    // [CHANGE]: stop using mod_ext as we can have A.B(C).t
//  | mod_ext_longident DOT LOWERCASE_IDENT
    | CAPITALIZED_IDENT (LPAREN CAPITALIZED_IDENT (DOT CAPITALIZED_IDENT)* RPAREN)? DOT type_longident

mod_longident ::=
    CAPITALIZED_IDENT (DOT CAPITALIZED_IDENT)*

class_longident ::=
    LOWERCASE_IDENT
  | { CAPITALIZED_IDENT (DOT CAPITALIZED_IDENT)* } DOT LOWERCASE_IDENT

/* Miscellaneous */

name_tag ::=
    BACKTICK ident