// Look at
// https://github.com/sidharthkuruvila/ocaml-ide/blob/master/parser/ocaml.bnf
{
    parserClass="com.ocaml.lang.lexer.OCamlParser"
    parserUtilClass='com.ocaml.lang.lexer.OCamlParserUtil'

    // every class generated implement/extends these
    implements="com.ocaml.lang.core.OCamlElement"
    extends="com.ocaml.lang.core.OCamlElementImpl"

    // generate the types of the element here
    elementTypeHolderClass='com.or.lang.OCamlTypes'
    // element
    elementTypeClass="com.ocaml.lang.core.OCamlElementType"
    // token
    tokenTypeClass="com.ocaml.lang.core.OCamlTokenType"

    // prefix / suffix / output
    psiClassPrefix="OCaml"
    psiImplClassSuffix="Impl"
    psiPackage="com.ocaml.lang.core.psi"
    psiImplPackage="com.ocaml.lang.core.psi.impl"

    tokens = [
        AND              =  'and'
        AS               =  'as'
        ASSERT           =  'assert'
        BEGIN            =  'begin'
        CLASS            =  'class'
        CONSTRAINT       =  'constraint'
        DO               =  'do'
        DONE             =  'done'
        DOWNTO           =  'downto'
        ELSE             =  'else'
        END              =  'end'
        ENDIF            =  'endif'
        EXCEPTION        =  'exception'
        EXTERNAL         =  'external'
        FOR              =  'for'
        FUN              =  'fun'
        FUNCTION         =  'function'
        FUNCTOR          =  'functor'
        IF               =  'if'
        IN               =  'in'
        INCLUDE          =  'include'
        INHERIT          =  'inherit'
        INITIALIZER      =  'initializer'
        LAZY             =  'lazy'
        LET              =  'let'
        MODULE           =  'module'
        MUTABLE          =  'mutable'
        NEW              =  'new'
        NOT              =  'not'
        NONREC           =  'nonrec'
        OBJECT           =  'object'
        OF               =  'of'
        OPEN             =  'open'
        OR               =  'or'
        PUB              =  'pub'
        PRI              =  'pri'
        REC              =  'rec'
        SIG              =  'sig'
        STRUCT           =  'struct'
        SWITCH           =  'switch'
        THEN             =  'then'
        TO               =  'to'
        TRY              =  'try'
        TYPE             =  'type'
        VAL              =  'val'
        VIRTUAL          =  'virtual'
        WHEN             =  'when'
        WHILE            =  'while'
        WITH             =  'with'
        RAW              =  'raw'

        MOD              =  'mod'
        LAND             =  'land'
        LOR              =  'lor'
        LXOR             =  'lxor'
        LSL              =  'lsl'
        LSR              =  'lsr'
        ASR              =  'asr'

        UNIT             =  'unit'
        REF              =  'ref'
        RAISE            =  'raise'
        METHOD           =  'method'
        PRIVATE          =  'private'
        MATCH            =  'match'

        OPTION           =  'option'
        NONE             =  'None'
        SOME             =  'Some'

        BOOL_VALUE       =  'false'
        BOOL_VALUE       =  'true'

        UNDERSCORE       =  '_'

        CHAR_VALUE="regexp:'(\\\\|\\'|\\n|\\t|\\b|\\r|\\\"|.)'"
        STRING_VALUE="regexp:\"(\\\\|\\'|\\n|\\t|\\b|\\r|\\\"|.)*\""
        LIDENT="regexp:[a-z_][A-Za-z_0-9']*"
        UIDENT="regexp:[A-Z][A-Za-z_0-9']*"
        INT_VALUE="regexp:\d+"
        FLOAT_VALUE="regexp:\d+\.\d*"

        TYPE_ARGUMENT="regexp:'[a-z_][A-Za-z_0-9']*"
        POLY_VARIANT="regexp:`(([a-z_][A-Za-z_0-9']*)|([A-Z][A-Za-z_0-9']*))"
        SINGLE_COMMENT= "regexp:\(\*[^\n]*\*\)"
        MULTI_COMMENT="regexp:\(\*.*\*\)"
        ANNOTATION="regexp:\[@@.*]"

        DIRECTIVE_IF     =  '#if'
        DIRECTIVE_ELSE   =  '#else'
        DIRECTIVE_ELIF   =  '#elif'
        DIRECTIVE_ENDIF  =  '#endif'
        DIRECTIVE_END    =  '#end'

        SHARPSHARP       =  '##'
        AT_SIGN_2        =  '@@'
        AT_SIGN_3        =  '@@@'

        SHORTCUT         =  '::'
        ARROW            =  '=>'
        RIGHT_ARROW      =  '->'
        LEFT_ARROW       =  '<-'
        PIPE_FORWARD     =  '|>'
        TAG_LT_SLASH     =  '</'
        TAG_AUTO_CLOSE   =  '/>'
        LARRAY           =  '[|'
        RARRAY           =  '|]'

        EQEQEQ           =  '==='
        EQEQ             =  '=='
        EQ               =  '='
        NOT_EQEQ         =  '!=='
        NOT_EQ           =  '!='
        COLON_EQ         =  ':='
        COLON_GT         =  ':>'
        LT_OR_EQUAL      =  '<='
        GT_OR_EQUAL      =  '>='
        SEMISEMI         =  ';;'
        L_OR             =  '||'
        L_AND            =  '&&'
        OP_STRUCT_DIFF   =  '<>'

        COMMA            =  ','
        COLON            =  ':'
        SEMI             =  ';'
        SINGLE_QUOTE     =  "'"
        DOTDOTDOT        =  '...'
        DOTDOT           =  '..'
        DOT              =  '.'
        PIPE             =  '|'
        LPAREN           =  '('
        RPAREN           =  ')'
        LBRACE           =  '{'
        RBRACE           =  '}'
        LBRACKET         =  '['
        RBRACKET         =  ']'
        AT_SIGN          =  '@'
        SHARP            =  '#'
        QUESTION_MARK    =  '?'
        EXCLAMATION_MARK =  '!'
        DOLLAR           =  '$'
        BACKTICK         =  '`'
        TILDE            =  '~'
        AMPERSAND        =  '&'

        LT               =  '<'
        GT               =  '>'

        CARET            =  '\^'
        PLUSDOT          =  '+.'
        MINUSDOT         =  '-.'
        SLASHDOT         =  '/.'
        STARDOT          =  '*.'
        PLUS             =  '+'
        MINUS            =  '-'
        SLASH            =  '/'
        STAR             =  '*'
        PERCENT          =  '%'
        ]
}

// empty rule to force generation
File ::=